<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="nPoziOQzb5Lb3pPO9SGvdEUa54TVyk1_z_kbLwqQ7r0">
  <meta name="baidu-site-verification" content="FAhxzOEgJW">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="猫屎咖啡">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="猫屎咖啡">
<meta property="article:author" content="猫屎咖啡">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>猫屎咖啡</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">猫屎咖啡</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%80%E8%BF%B0/" class="post-title-link" itemprop="url">动态规划简述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-25 18:58:51 / Modified: 19:56:37" itemprop="dateCreated datePublished" datetime="2020-05-25T18:58:51+08:00">2020-05-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近总是碰到动态规划的问题，简单记录一下。</p>
<p>动态规划其实就是重叠子问题，将一个问题分解为若干个小问题求解的一种方式。就是先解决子问题，然后逐步解决原来的大问题。</p>
<p>举例来说明：</p>
<ol>
<li>斐波那契数列</li>
</ol>
<p>之前的文章有讲递归求解斐波那契数列，今天看一看动态规划怎么求解。</p>
<p>我们知道，斐波那契数列的每一个数，都是它之前两个数的和，也就是只和它之前的两个数有关系，假设斐波那契数列的第一个数我们定义为<code>f(1)</code>，第n个数定义为<code>f(n)</code>。</p>
<p>我们写一下这个问题的状态转移方程，然后找一下问题的递归出口，然后就可以按照这个方程来编写代码了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(n) &#x3D; 1                n&#x3D;1 or n&#x3D;2 </span><br><span class="line">f(n) &#x3D; f(n-1) + f(n-2)  n &gt; 2</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>]; <span class="comment">//定义一个数组，用来记录小问题求解的每一步结果，为了方便，dp[0]不存放数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照状态转移方程来编写的代码</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]; <span class="comment">//状态转移方程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>台阶问题</li>
</ol>
<p>有一座高度是n级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。</p>
<p>我们假设f(n)代表走到第n级台阶一共的走法，根据题目描述我们知道，一次只能走一级或者两级，我们直接看走到第n级台阶，这一步可能是从第n-1级台阶走了一级上去的，也可能是从第n-2级台阶走了两级上去的。这个问题就可以转换成来求解f(n-1)和f(n-2)。我们写一下这个问题的状态转移方程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(n) &#x3D; f(n-1) + f(n-2)  n &gt; 2</span><br><span class="line">f(n) &#x3D; 1                n &#x3D; 1</span><br><span class="line">f(n) &#x3D; 2                n &#x3D; 2</span><br></pre></td></tr></table></figure>

<p>同样，有状态转移方程，也知道了递归出口，这个问题也可以用递归的方式来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climb</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> climb(n - <span class="number">1</span>) + climb(n - <span class="number">2</span>); <span class="comment">//状态转移方程</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讲递归的时候，我们已经知道，递归的性能不好，函数堆栈比较深，时间复杂度很高，我们可以使用动态规划的另一种方式，备忘录方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climb2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>]; <span class="comment">//同样，定义一个数组，用来记录小问题求解的每一步结果，为了方便，dp[0]不存放数据</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]; <span class="comment">//状态转移方程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完这两个简单的问题，相信大家对动态规划也有了一定的了解，其实就是分解问题，找问题的递归出口，推导状态转移方程，然后按照状态转移方程来编写代码就可以了。</p>
<p>我们来看一个进阶一点的动态规划题目，下面是题目描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有一排石碓，每碓石头的数量不一样，想办法石碓中拿到最多的石头，不能拿相邻的石头，例：</span><br><span class="line"></span><br><span class="line">nums : [1 4 9 34 2 3]&#x3D; 41</span><br><span class="line">nums : [1 8 1 1 8 1]&#x3D; 16</span><br></pre></td></tr></table></figure>

<p>还是，来找递归出口以及状态转移方程</p>
<p>假设f(6)的含义为，到数组下标为6，能拿到的最多的石头数，也就是到数组下标为6，此问题的最佳解决方案，f(5)代表到数组下标为5，最佳方案是什么。</p>
<p>详细说明一下</p>
<p>下标为6这个位置的数字，有两种方案，选&amp;不选。</p>
<p>假设我们在拿石头的时候选了下标为6的数字，那么方程就可以这么写</p>
<p>f(6) = f(4) + arr[6]</p>
<p>如果不选呢</p>
<p>f(6) = f(5)</p>
<p>那么f(6)的最佳方案就是max(f(4) + arr[6],f(5))</p>
<p>来写一下状态转移方程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(n) &#x3D; f(n-2) + arr[n]  选n</span><br><span class="line">f(n) &#x3D; f(n-1)       不选n</span><br><span class="line">f(0) &#x3D; arr[0]</span><br><span class="line">f(1) &#x3D; max(arr[0],arr[1])</span><br></pre></td></tr></table></figure>

<ul>
<li>递归求解</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">RecOpt</span><span class="params">(<span class="keyword">int</span> [] nums, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        <span class="keyword">int</span> a = RecOpt(nums,n-<span class="number">2</span>) + nums[n];</span><br><span class="line">        <span class="keyword">int</span> b = RecOpt(nums,n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>备忘录求解</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">DpOpt</span><span class="params">(<span class="keyword">int</span> [] nums)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> [] opt = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    opt[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    opt[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态转移方程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = opt[i-<span class="number">2</span>] + nums[i];</span><br><span class="line">        <span class="keyword">int</span> b = opt[i-<span class="number">1</span>];</span><br><span class="line">        opt[i] = Math.max(a,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> opt[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/20/Java%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%8F%96%E5%A4%A7%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/Java%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%8F%96%E5%A4%A7%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">Java如何快速读取大文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-20 10:16:47 / Modified: 10:33:47" itemprop="dateCreated datePublished" datetime="2020-05-20T10:16:47+08:00">2020-05-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近看到一种快速读取大文件的方法，记录一下，与平时常用的方法做一下对比。</p>
<ol>
<li>普通输入流</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 普通输入流</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> filename</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inputStream</span><span class="params">(Path filename)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream is = Files.newInputStream(filename)) &#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span>((c = is.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>带缓冲的输入流</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 带缓冲的输入流</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> filename</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bufferedInputStream</span><span class="params">(Path filename)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> BufferedInputStream(Files.newInputStream(filename))) &#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span>((c = is.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>随机访问文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 随机访问文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> filename</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">randomAccessFile</span><span class="params">(Path filename)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (RandomAccessFile randomAccessFile  = <span class="keyword">new</span> RandomAccessFile(filename.toFile(), <span class="string">"r"</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; randomAccessFile.length(); i++) &#123;</span><br><span class="line">            randomAccessFile.seek(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>内存映射文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 内存映射文件</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> filename</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mappedFile</span><span class="params">(Path filename)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileChannel fileChannel = FileChannel.open(filename)) &#123;</span><br><span class="line">        <span class="keyword">long</span> size = fileChannel.size();</span><br><span class="line">        MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            mappedByteBuffer.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>测试主类 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试文件大小为987.2M</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//bufferedInputStream(Paths.get("/Users/constantine/Downloads/jisuzhuisha.mp4"));//22038</span></span><br><span class="line">        <span class="comment">//inputStream(Paths.get("/Users/constantine/Downloads/jisuzhuisha.mp4")); //龟速，没有耐心等出结果</span></span><br><span class="line">        <span class="comment">//randomAccessFile(Paths.get("/Users/constantine/Downloads/jisuzhuisha.mp4"));//龟速，没有耐心等出结果</span></span><br><span class="line">        mappedFile(Paths.get(<span class="string">"/Users/constantine/Downloads/jisuzhuisha.mp4"</span>));<span class="comment">//816</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end-start);</span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，内存映射文件的方式比传统方式快了N倍，这就是Java NIO的威力。</p>
<ul>
<li>简单介绍一下内存映射文件：</li>
</ul>
<p>所谓内存映射文件，就是将文件映射到内存，文件对应于内存中的一个字节数组，对文件的操作变为对这个字节数组的操作，而字节数组的操作直接映射到文件上。这种映射可以是映射文件全部区域，也可以是只映射一部分区域。</p>
<p>不过，这种映射是操作系统提供的一种假象，文件一般不会马上加载到内存，操作系统只是记录下了这回事，当实际发生读写时，才会按需加载。操作系统一般是按页加载的，页可以理解为就是一块，页的大小与操作系统和硬件相关，典型的配置可能是4K, 8K等，当操作系统发现读写区域不在内存时，就会加载该区域对应的一个页到内存。</p>
<p>这种按需加载的方式，使得内存映射文件可以方便处理非常大的文件，内存放不下整个文件也不要紧，操作系统会自动进行处理，将需要的内容读到内存，将修改的内容保存到硬盘，将不再使用的内存释放。</p>
<p>在应用程序写的时候，它写的是内存中的字节数组，这个内容什么时候同步到文件上呢？这个时机是不确定的，由操作系统决定，不过，只要操作系统不崩溃，操作系统会保证同步到文件上，即使映射这个文件的应用程序已经退出了。</p>
<p>在一般的文件读写中，会有两次数据拷贝，一次是从硬盘拷贝到操作系统内核，另一次是从操作系统内核拷贝到用户态的应用程序。而在内存映射文件中，一般情况下，只有一次拷贝，且内存分配在操作系统内核，应用程序访问的就是操作系统的内核内存空间，这显然要比普通的读写效率更高。</p>
<p>内存映射文件的另一个重要特点是，它可以被多个不同的应用程序共享，多个程序可以映射同一个文件，映射到同一块内存区域，一个程序对内存的修改，可以让其他程序也看到，这使得它特别适合用于不同应用程序之间的通信。</p>
<p>操作系统自身在加载可执行文件的时候，一般都利用了内存映射文件，比如：</p>
<ol>
<li>按需加载代码，只有当前运行的代码在内存，其他暂时用不到的代码还在硬盘</li>
<li>同时启动多次同一个可执行文件，文件代码在内存也只有一份</li>
<li>不同应用程序共享的动态链接库代码在内存也只有一份 </li>
<li>内存映射文件也有局限性，比如，它不太适合处理小文件，它是按页分配内存的，对于小文件，会浪费空间，另外，映射文件要消耗一定的操作系统资源，初始化比较慢。</li>
</ol>
<p>简单总结下，对于一般的文件读写不需要使用内存映射文件，但如果处理的是大文件，要求极高的读写效率，比如数据库系统，或者需要在不同程序间进行共享和通信，那就可以考虑内存映射文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/15/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/15/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">Java代理模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-15 10:17:17 / Modified: 15:10:56" itemprop="dateCreated datePublished" datetime="2020-05-15T10:17:17+08:00">2020-05-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>代理模式的含义是，给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理模式是一种结构型设计模式。</p>
<p>代理模式角色分为 3 种：</p>
<p>Subject（抽象主题角色）：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；</p>
<p>RealSubject（真实主题角色）：真正实现业务逻辑的类；</p>
<p>Proxy（代理主题角色）：用来代理和封装真实主题；</p>
<p>先来看看静态代理</p>
<p>编写一个接口（抽象主题角色）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写该接口的实现类（真实主题角色）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"查询 selectById"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新 update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写一个代理类 UserServiceProxy（代理主题角色），代理类需要实现<code>UserService</code>，对<code>UserServiceImpl</code>进行功能一些增强</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.select();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        target.update();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;     <span class="comment">// 在执行方法之前执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;      <span class="comment">// 在执行方法之后执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后测试一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userServiceImpl = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserService proxy = <span class="keyword">new</span> UserServiceProxy(userServiceImpl);<span class="comment">//传入需要被代理的角色</span></span><br><span class="line"></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Fri May <span class="number">15</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">28</span> CST <span class="number">2020</span>] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Fri May <span class="number">15</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">28</span> CST <span class="number">2020</span>] </span><br><span class="line">log start time [Fri May <span class="number">15</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">28</span> CST <span class="number">2020</span>] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Fri May <span class="number">15</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">28</span> CST <span class="number">2020</span>]</span><br></pre></td></tr></table></figure>

<p>可以看到，我们通过代理类对<code>userServiceImpl</code>的两个方法进行了增强，在方法执行前后打印了一些日志。</p>
<p>大家可能会想到，Spring中AOP功能，也可以在一些方法执行前后打印一些日志，做一些操作。其实这也是用了代理模式，但是SpringAOP中用的并不是上述的简单的静态代理，而是使用的动态代理，jdk动态代理，或者cglib动态代理。</p>
<p>静态代理有一些优缺点我们来看一下：</p>
<ul>
<li>静态代理优点</li>
</ul>
<ol>
<li>达到了功能增强的目的，而且没有侵入原代码</li>
</ol>
<ul>
<li>静态代理缺点</li>
</ul>
<ol>
<li>当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：<br>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大<br>新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类</li>
<li>当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护。</li>
</ol>
<p>一句话总结缺点，不够灵活简便。</p>
<p>那么来看看动态代理</p>
<ol>
<li>jdk动态代理</li>
</ol>
<p>jdk动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code>，一看到<code>reflect</code>包，应该就能想到动态代理利用看Java的反射特性。</p>
<p>我们还编写一个代理类，实现上述静态代理中打印日志的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Object target;  <span class="comment">// 被代理的对象，实际的方法执行者</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = method.invoke(target, args);  <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之前执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之后执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写一个主类来测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建被代理的对象，UserService接口的实现类</span></span><br><span class="line">        UserServiceImpl userServiceImpl = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        <span class="comment">// 2. 获取对应的 ClassLoader</span></span><br><span class="line">        ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span></span><br><span class="line">        Class[] interfaces = userServiceImpl.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span></span><br><span class="line">        <span class="comment">//     这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl</span></span><br><span class="line">        InvocationHandler logHandler = <span class="keyword">new</span> LogHandler(userServiceImpl);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		   5.根据上面提供的信息，创建代理对象 在这个过程中，</span></span><br><span class="line"><span class="comment">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span><br><span class="line"><span class="comment">               b.然后根据相应的字节码转换成对应的class，</span></span><br><span class="line"><span class="comment">               c.然后调用newInstance()创建代理实例</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        UserService proxy = (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);</span><br><span class="line">        <span class="comment">// 调用代理的方法</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Fri May <span class="number">15</span> <span class="number">10</span>:<span class="number">38</span>:<span class="number">31</span> CST <span class="number">2020</span>] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Fri May <span class="number">15</span> <span class="number">10</span>:<span class="number">38</span>:<span class="number">31</span> CST <span class="number">2020</span>] </span><br><span class="line">log start time [Fri May <span class="number">15</span> <span class="number">10</span>:<span class="number">38</span>:<span class="number">31</span> CST <span class="number">2020</span>] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Fri May <span class="number">15</span> <span class="number">10</span>:<span class="number">38</span>:<span class="number">31</span> CST <span class="number">2020</span>]</span><br></pre></td></tr></table></figure>

<p>InvocationHandler 和 Proxy 的主要方法介绍如下：</p>
<ul>
<li>java.lang.reflect.InvocationHandler<br><code>Object invoke(Object proxy, Method method, Object[] args)</code> 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</li>
</ul>
<ul>
<li>java.lang.reflect.Proxy<br><code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code> 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</li>
</ul>
<ol start="2">
<li>cglib动态代理</li>
</ol>
<p>maven引入CGLIB包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意，从<code>Spring 3.2</code>开始， 不需要定义cglib依赖关系它已经被重新打包并直接集成在 <code>spring-core</code> 这个jar包中。</li>
</ul>
<p>编写一个UserDao类，它没有接口，只有两个方法，select() 和 update()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDao 查询 selectById"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDao 更新 update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写一个 LogInterceptor ，继承了 MethodInterceptor，用于方法的拦截回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 表示要进行增强的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 表示拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int--&gt;Integer、long-Long、double--&gt;Double</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = methodProxy.invokeSuper(object, objects);   <span class="comment">// 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法</span></span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LogInterceptor logInterceptor = <span class="keyword">new</span> LogInterceptor();</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(UserDao.class);   <span class="comment">// 设置超类，cglib是通过继承来实现的</span></span><br><span class="line">        enhancer.setCallback(logInterceptor);</span><br><span class="line"></span><br><span class="line">        UserDao proxy = (UserDao) enhancer.create();   <span class="comment">// 创建代理类</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Fri May <span class="number">15</span> <span class="number">10</span>:<span class="number">50</span>:<span class="number">36</span> CST <span class="number">2020</span>] </span><br><span class="line">UserDao 查询 selectById</span><br><span class="line">log end time [Fri May <span class="number">15</span> <span class="number">10</span>:<span class="number">50</span>:<span class="number">36</span> CST <span class="number">2020</span>] </span><br><span class="line">log start time [Fri May <span class="number">15</span> <span class="number">10</span>:<span class="number">50</span>:<span class="number">36</span> CST <span class="number">2020</span>] </span><br><span class="line">UserDao 更新 update</span><br><span class="line">log end time [Fri May <span class="number">15</span> <span class="number">10</span>:<span class="number">50</span>:<span class="number">36</span> CST <span class="number">2020</span>]</span><br></pre></td></tr></table></figure>

<p>还可以进一步多个 MethodInterceptor 进行过滤筛选</p>
<p>定义<code>LogInterceptor2</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor2</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log2 start time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"log2 end time [%s] "</span>, <span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个回调过滤器，在cglib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFilter</span> <span class="keyword">implements</span> <span class="title">CallbackFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"select"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// Callback 列表第1个拦截器 UserDao.select方法执行第一个拦截器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">// Callback 列表第2个拦截器，return 2 则为第3个，以此类推</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LogInterceptor logInterceptor = <span class="keyword">new</span> LogInterceptor();</span><br><span class="line">        LogInterceptor2 logInterceptor2 = <span class="keyword">new</span> LogInterceptor2();</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(UserDao.class);   <span class="comment">// 设置超类，cglib是通过继承来实现的</span></span><br><span class="line">        enhancer.setCallbacks(<span class="keyword">new</span> Callback[]&#123;logInterceptor, logInterceptor2, NoOp.INSTANCE&#125;);   <span class="comment">// 设置多个拦截器，NoOp.INSTANCE是一个空拦截器，不做任何处理</span></span><br><span class="line">        enhancer.setCallbackFilter(<span class="keyword">new</span> DaoFilter());</span><br><span class="line"></span><br><span class="line">        UserDao proxy = (UserDao) enhancer.create();   <span class="comment">// 创建代理类</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Fri May <span class="number">15</span> <span class="number">10</span>:<span class="number">54</span>:<span class="number">18</span> CST <span class="number">2020</span>] </span><br><span class="line">UserDao 查询 selectById</span><br><span class="line">log end time [Fri May <span class="number">15</span> <span class="number">10</span>:<span class="number">54</span>:<span class="number">18</span> CST <span class="number">2020</span>] </span><br><span class="line">log2 start time [Fri May <span class="number">15</span> <span class="number">10</span>:<span class="number">54</span>:<span class="number">18</span> CST <span class="number">2020</span>] </span><br><span class="line">UserDao 更新 update</span><br><span class="line">log2 end time [Fri May <span class="number">15</span> <span class="number">10</span>:<span class="number">54</span>:<span class="number">18</span> CST <span class="number">2020</span>]</span><br></pre></td></tr></table></figure>
<p>可以看到</p>
<ul>
<li>select方法执行第一个拦截器，打印<code>log</code></li>
<li>update方法执行第二个拦截器，打印<code>log2</code></li>
</ul>
<p>cglib 创建动态代理类的模式是：</p>
<ol>
<li>查找目标类上的所有非final 的public类型的方法定义；</li>
<li>将这些方法的定义转换成字节码；</li>
<li>将组成的字节码转换成相应的代理的class对象；</li>
<li>实现 MethodInterceptor接口，用来处理对代理类上所有方法的请求</li>
</ol>
<p>jdk动态代理与cglib动态代理对比:</p>
<ul>
<li>jdk动态代理：基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。</li>
<li>cglib动态代理：基于ASM机制实现，通过生成业务类的子类作为代理类。</li>
</ul>
<p>jdk动态代理的优势：</p>
<ol>
<li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。</li>
<li>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li>
<li>代码实现简单。</li>
</ol>
<p>cglib动态代理的优势：</p>
<ol>
<li>无需实现接口，达到代理类无侵入</li>
<li>只操作我们关心的类，而不必为其他相关类增加工作量。</li>
<li>高性能</li>
</ol>
<p>另外：</p>
<ul>
<li>Spring5 之前的版本 AOP 在默认情况下是使用 jdk 动态代理的，之后的版本默认使用 jdk 动态代理，如果对象没有实现接口，则使用 cglib 代理。</li>
<li>在 SpringBoot 1.5.x 版本中，默认还是使用 jdk 动态代理的。</li>
<li>SpringBoot 2.x 为何默认使用 cglib</li>
</ul>
<p>SpringBoot 2.x 版本为什么要默认使用 Cglib 来实现 AOP 呢？这么做的好处又是什么呢？</p>
<p>假设，我们有一个UserServiceImpl和UserService类，此时需要在UserContoller中使用UserService。在 Spring 中通常都习惯这样写代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserService userService;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，无论是使用 jdk 动态代理，还是 cglib 都不会出现问题。</p>
<p>但是，如果你的代码是这样的呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserServiceImpl userService;</span><br></pre></td></tr></table></figure>

<p>这个时候，如果我们是使用 JDK 动态代理，那在启动时就会报错：</p>
<p>因为 JDK 动态代理是基于接口的，代理生成的对象只能赋值给接口变量。<br>而 CGLIB 就不存在这个问题。因为 CGLIB 是通过生成子类来实现的，代理对象无论是赋值给接口还是实现类这两者都是代理对象的父类。<br>SpringBoot 正是出于这种考虑，于是在 2.x 版本中，将 AOP 默认实现改为了 CGLIB。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B9%9D%EF%BC%89%E4%B9%8B%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B9%9D%EF%BC%89%E4%B9%8B%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">Java并发编程（九）之指令重排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-28 09:30:37" itemprop="dateCreated datePublished" datetime="2020-04-28T09:30:37+08:00">2020-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-29 16:36:10" itemprop="dateModified" datetime="2020-04-29T16:36:10+08:00">2020-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java内存模型允许编译器和处理器对指令进行重排序以提高程序性能，但是只会对没有数据依赖性的指令进行重排序。单线程的情况下，重排序可以保证运行结果与不进行重排序运行结果一致，但在多线程下就会存在问题。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;      <span class="comment">//(1)</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;      <span class="comment">//(2)</span></span><br><span class="line"><span class="keyword">int</span> c = a + b;  <span class="comment">//(3)</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，变量 c 的值依赖于 a 和 b ，所以在重排序之后，需要保证(1)和(2)的操作在(3)之前，c的值就不会受到影响，但是(1)和(2)的操作谁先执行在重排序之后并不能确定。这样的情况在单线程下不会出现问题，因为单线程下不会影响最终结果。</p>
<p>下面看个多线程的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstructionReorder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                <span class="keyword">if</span>(ready)&#123; <span class="comment">//(1)</span></span><br><span class="line">                    System.out.println(num+num); <span class="comment">//(2)</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"read thread..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            num = <span class="number">2</span>; <span class="comment">//(3)</span></span><br><span class="line">            ready = <span class="keyword">true</span>; <span class="comment">//(4)</span></span><br><span class="line">            System.out.println(<span class="string">"write thread set over"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        ReadThread readThread = <span class="keyword">new</span> ReadThread();</span><br><span class="line">        readThread.start();</span><br><span class="line"></span><br><span class="line">        WriteThread writeThread = <span class="keyword">new</span> WriteThread();</span><br><span class="line">        writeThread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        readThread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"main exit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码里变量都没有被<code>volatile</code>修饰，也没有任何同步措施，在多线程的情况下存在内存可见性问题。但先不考虑这个问题，在不考虑内存可见性问题的情况下，这段程序一定会输出4吗？答案是不一定，由于代码(1)(2)和(3)(4)之间不存在依赖关系，所以(3)(4)可能被重排序为先执行(4)，再执行(3)，那么执行(4)之后，读线程可能已经执行了(1)操作，并且在(3)操作执行前开始执行(2)操作，这时候输出的结果是0而不是4。</p>
<p>解决方法就是使用<code>volatile</code>修饰共享变量，可以避免重排序与内存可见性问题。</p>
<p>写<code>volatile</code>变量时，可以确保<code>volatile</code>写之前的操作不会被重排序到<code>volatile</code>写之后，读<code>volatile</code>变量时，可以确保<code>volatile</code>读之后的操作不会被编译器重排序到<code>volatile</code>读之前。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8BCAS%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8BCAS%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Java并发编程（八）之CAS操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-22 10:17:18" itemprop="dateCreated datePublished" datetime="2020-04-22T10:17:18+08:00">2020-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-24 15:58:28" itemprop="dateModified" datetime="2020-04-24T15:58:28+08:00">2020-04-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>学习<code>CAS</code>之前，先了解一下什么是原子性操作，所谓的原子性操作，是指进行一系列操作的时候，这一系列操作要么全部执行，要么全部不执行，不会出现只执行一部分的情况。</p>
<p>例如，我们对一个变量进行+1（例如<code>x++</code>）操作的时候，首先要读取当前变量值，然后+1，然后再将新值赋值给该变量。这就是一个<code>读-改-写</code>的过程。如果这个过程不是原子性的，那么久就会出现线程安全问题。虽然<code>x++</code>只有一行代码，但是其中的操作并不是一步而成的，其操作不是原子性的。</p>
<p>通过之前所学，我们知道<code>synchronized</code>关键字可以解决线程安全问题，也就是<code>内存可见性</code>与<code>原子性</code>。但是<code>synchronized</code>是独占锁，没有获取到锁的线程将会被阻塞，会降低程序性能。例如下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeCount</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">incCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到两个方法都加了锁，但是同一时间只能有一个线程来调用，其中<code>getCount</code>方法是只读方法，多个线程同时调用不会有线程安全问题，但是加了synchronized关键字之后，同一时间只能有一个线程来调用，降低了并发性能。那能不能去掉这个关键字呢，也不能去掉，因为我们还需要synchronized来保证内存可见性。</p>
<h3 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h3><p>我们学过两个关键字<code>synchronized</code>与<code>volatile</code>，两者都可以解决共享变量内存可见性的问题，但是，<code>volatile</code>不能解决<code>读-改-写</code>等原子性的问题，<code>synchronized</code>能够解决原子性问题，但是其性能开销大。</p>
<p>CAS操作是<code>Compare And Swap</code>，是JDK提供的非阻塞原子性操作，通过硬件保证了<code>比较-更新</code>操作的原子性。JDK里面的<code>Unsafe</code>类提供了一系列<code>compareAndSwap*</code>方法，比如<code>compareAndSwapInt</code>和<code>compareAndSwapLong</code>。下面我们以<code>compareAndSwapLong</code>为例子进行简单介绍。</p>
<p><code>boolean compareAndSwapLong(Object obj,long valueOffset,long expect,long update)</code>方法：四个参数，含义分别是：对象内存位置，对象中变量的偏移量，变量的预期值，新的值。其操作的含义是，若对象<code>obj</code>中内存偏移量为<code>valueOffset</code>的变量值为<code>expect</code>，则用新的值<code>update</code>替换旧的值，也就是替换<code>expect</code>。这是处理器提供的一个原子性命令。</p>
<p>CAS操作虽然很高效地解决了原子操作，但是仍然存在三大问题：<code>ABA问题</code>、<code>循环开销时间大</code>、<code>只能保证一个共享变量的原子操作</code></p>
<ol>
<li>ABA问题<br>CAS在操作值得时候，会检查值有没有发生变化，如果没有发生变化就更新。若是一个值原来是A，变成了B，后来又变回了A（举例：线程1获取变量值为A后，在执行CAS之前，线程2使用CAS修改变量的值为B，然后又修改变量值为A），那么使用CAS操作时检查其值得结果是没有变化，但其实是变化了，虽然线程1执行CAS操作时变量的值为A，但是这个A已经不是线程1获取变量值时的A了，这就是ABA问题。</li>
</ol>
<p>看起来好像最后还是正确的修改了变量值，但其实是丢失了变量值得修改记录。此问题的解决方案就是使用版本号，在变量前面追加上版本号，每次变量更新的时候把版本号+1，这样<code>A-B-A</code>就会变为<code>1A-2B-3A</code>。从Java1.5开始，JDK的Atomic包里就提供了一个类<code>AtomicStampedReference</code>来解决ABA问题，其中<code>compareAndSet</code>方法的作用就是，先检查当前引用是否等于预期引用，并检查当前标志是否等于预期标志，如果全部相等，就进行更新。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expectedReference,//预期引用</span></span></span><br><span class="line"><span class="function"><span class="params">                                V newReference,//更新后引用</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> expectedStamp,//当前标志</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> newStamp)</span><span class="comment">//更新后标志</span></span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>循环时间长，开销大<br>自旋CAS如果长时间不成功，会给CPU带来非常大的开销。</p>
</li>
<li><p>只能保证一个共享变量的原子操作<br>当对一个共享变量执行操作的时候，我们可以使用CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。从Java1.5开始，JDK的Atomic包里就提供了一个类<code>AtomicReference</code>类来保证引用对象直接的原子性，就可以多个变量放在一个对象里来进行CAS操作。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89%E4%B9%8B%E5%90%84%E7%A7%8D%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89%E4%B9%8B%E5%90%84%E7%A7%8D%E9%94%81/" class="post-title-link" itemprop="url">Java并发编程（七）之各种锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-20 15:31:36" itemprop="dateCreated datePublished" datetime="2020-04-20T15:31:36+08:00">2020-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-22 10:06:35" itemprop="dateModified" datetime="2020-04-22T10:06:35+08:00">2020-04-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们已经知道了在线程同步问题上，我们可以通过使用<code>synchronized</code>加锁来保证线程安全。简单介绍一下各种锁的概念以及含义。</p>
<h3 id="1-乐观锁与悲观锁"><a href="#1-乐观锁与悲观锁" class="headerlink" title="1. 乐观锁与悲观锁"></a>1. 乐观锁与悲观锁</h3><p>乐观锁和悲观锁是在数据库中引入的名词，但是在并发包锁里面也引入了类似的思想（计算机科学中很多思想都是类似的），所以也简单了解一下。</p>
<ul>
<li>乐观锁</li>
</ul>
<p>乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。</p>
<p>通常实现是这样的：在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。也就是先查询出那条记录，获取出version字段,如果要对那条记录进行操作(更新),则先判断此刻version的值是否与刚刚查询出来时的version的值相等，如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将version字段的值加1；如果更新时发现此刻的version值与刚刚获取出来的version的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。</p>
<ul>
<li>悲观锁</li>
</ul>
<p>与乐观锁相对应的就是悲观锁了。悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了</p>
<p>悲观锁又分为共享锁与排它锁</p>
<pre><code>1. 共享锁
共享锁指的就是对于多个不同的事务，对同一个资源共享同一个锁。相当于对于同一把门，它拥有多个钥匙一样，这个就是所谓的共享锁。
刚刚说了，对于悲观锁，一般数据库已经实现了，共享锁也属于悲观锁的一种，那么共享锁在mysql中是通过什么命令来调用呢。通过查询资料，了解到通过在执行语句后面加上lock in share mode就代表对某些资源加上共享锁了。

2. 排它锁
排它锁与共享锁相对应，就是指对于多个不同的事务，对同一个资源只能有一把锁。与共享锁类似，在需要执行的语句后面加上for update就可以了</code></pre><h3 id="2-公平锁与非公平锁"><a href="#2-公平锁与非公平锁" class="headerlink" title="2. 公平锁与非公平锁"></a>2. 公平锁与非公平锁</h3><p>公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。而非公平锁不一定先到先得。</p>
<p>Java中<code>ReentrantLock</code>提供了公平和非公平锁的实现。</p>
<ul>
<li>公平锁 : <code>ReentrantLock lock = new ReentrantLock(true)</code></li>
<li>非公平锁 : <code>ReentrantLock lock = new ReentrantLock(false)</code></li>
</ul>
<p><code>注：</code>如果构造函数不传递参数，则默认是非公平锁。</p>
<p>简单举个例子解释一下：</p>
<p>加入线程A已经持有了锁，这时候线程B请求该锁时将会被挂起。当线程A释放锁之后，假设有一个线程C也需要获取该锁，如果采用非公平锁的方式，根据线程调度策略，线程B与线程C两者之一可能获取到锁；而如果使用公平锁，则需要把C挂起，让B先获取当前锁（先到先得）。</p>
<p>需要注意的是，在没有公平性需求的前提下，尽量使用非公平锁，因为公平锁会带来性能开销（很容易理解，公平锁需要一些其他操作来实现先到先得的公平性）。</p>
<h3 id="3-独占锁（排它锁）与共享锁"><a href="#3-独占锁（排它锁）与共享锁" class="headerlink" title="3. 独占锁（排它锁）与共享锁"></a>3. 独占锁（排它锁）与共享锁</h3><p>与上面数据库中的锁定义类似。</p>
<ul>
<li><p>独占锁<br>任何时候只有一个线程能得到锁，<code>ReentrantLock</code>就是以独占的方式实现的。由于每次访问共享资源都会先加上锁，限制了并发性。独占锁只允许在同一时间，由一个线程来进行读写操作，其他线程不能必须等待当前线程释放锁，才能进行读取操作。</p>
</li>
<li><p>共享锁<br>可以同时由多个线程持有，例如<code>ReadWriteLock</code>读写锁。它允许一个共享资源被多个线程同时进行<code>读</code>操作。</p>
</li>
</ul>
<h3 id="4-可重入锁"><a href="#4-可重入锁" class="headerlink" title="4. 可重入锁"></a>4. 可重入锁</h3><p>当一个线程要获取被另一个线程持有的独占锁的时候，将会被阻塞，那么该线程获取它自己已经获取的锁会不会被阻塞呢？如果不被阻塞，我们就说该锁是可以虫儿不的。</p>
<p>我们来看一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">helloA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">helloB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello b"</span>);</span><br><span class="line">        helloA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，两个方法<code>helloA</code>与<code>helloB</code>，都被<code>synchronized</code>修饰了，也就是都加了锁。我们知道对于普通同步方法，锁是当前实例对象，两个方法的锁是同一把锁，都是<code>this</code>。</p>
<p>在调用<code>helloB</code>方法的时候，会先获取到锁，然后打印输出<code>hello b</code>，然后再调用<code>helloA</code>方法，由于<code>helloA</code>方法也是加了锁的，所以需要再次获取一次该锁，若是该锁是不可重入的，那么调用线程将会被阻塞，<code>helloB</code>方法将会被阻塞。但是实际上，<code>synchronized</code>锁时可重入锁。其原理是，在锁内部维护一个标识，代表当前锁被哪个线程占用，然后会关联一个计数器（也就是上一篇中提到的monitor的进入数），一开始计数器为0，任何线程都可以获取该锁，当一个线程获取到锁之后（monitorenter指令），计数器的值加1，其他线程获取该锁的时候，会先判断锁的所有者是不是自己，若不是自己，该线程就会被阻塞。若是自己，就会把计数器的值加1，释放锁后计数器的值会减1（monitorexit指令），当计数器的值又变回0的时候，锁里面的线程标识会被重置为<code>null</code>，这时候被阻塞的线程，就会被唤醒来竞争获取该锁。</p>
<h3 id="5-自旋锁"><a href="#5-自旋锁" class="headerlink" title="5. 自旋锁"></a>5. 自旋锁</h3><p>Java中的线程是与操作系统中的线程一一对应的，当一个线程获取锁失败后，会切换到操作系统内核态挂起，当该线程获取到锁时，又需要将其切换到内核态唤醒。我们知道，操作系统从用户态切换到内核态是很耗性能的。而自旋锁在一定程度上避免了用户态与内核态之间的切换，自旋锁是当线程在获取锁的时候，如果该锁已被其他线程占有，当前线程不会马上切换到内核态阻塞自己，而是在不放弃CPU使用权的情况下，多次尝试获取该锁（默认次数是10，可以使用-XX：PreBlockSpinsh参数设置该值），在后面几次尝试中，其他线程可能已经释放了该锁。如果尝试指定次数后仍没有获取到锁，线程才会切换到内核态阻塞挂起自己。</p>
<p>由此看来，自旋锁换区线程阻塞调度的开销，是使用了CPU的时间，缺点就是，有可能这些CPU的时间被白白浪费了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8Bsynchronized%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8Bsynchronized%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">Java并发编程（六）之synchronized关键字原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-20 09:34:04 / Modified: 15:27:49" itemprop="dateCreated datePublished" datetime="2020-04-20T09:34:04+08:00">2020-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前我们说过在线程安全问题中如何使用<code>synchronized</code>关键字，现在我们看看，此关键字的原理是什么。</p>
<p>在多线程并发编程中<code>synchronized</code>一直是元老级的应用，虽说之前Java的版本中，这是一个重量级的锁，但是<code>Java SE 1.6</code>版本对此关键字进行了各种优化，有些情况下，它就表现的没那么笨重了。</p>
<p>先来看下利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。</p>
<ol>
<li>对于普通同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前类的Class对象。</li>
<li>对于同步方法块，锁是Synchonized括号里配置的对象。</li>
</ol>
<p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。若是线程在退出或者抛出异常的时候没有释放锁，那么共享资源将不会被释放，其他线程不能访问，程序就会陷入死锁。</p>
<p>在JVM中，同步的实现是通过监视器锁，也就是<code>Monitor</code>对象的进入和退出实现的。要么显示得通过 <code>monitorenter</code> 和 <code>monitorexit</code> 指令实现，要么隐示地通过方法调用和返回指令实现。</p>
<p>对于Java代码来说，或许最常用的同步实现就是同步方法。其中同步代码块是通过使用 <code>monitorenter</code> 和 <code>monitorexit</code> 实现的，而同步方法却是使用 <code>ACC_SYNCHRONIZED</code> 标记符隐示的实现，原理是通过方法调用指令检查该方法在常量池中是否包含 <code>ACC_SYNCHRONIZED</code> 标记符(这个我还没有去了解，所以就先略过，之后了解了再一起学习吧！)</p>
<p><code>monitorenter</code>指令是在编译后插入到同步代码块的开始位置，而<code>monitorexit</code>是插入到方法结束处和异常处，JVM要保证每个<code>monitorenter</code>必须有对应的<code>monitorexit</code>与之配对。任何对象都有一个<code>monitor</code>与之关联，当且一个<code>monitor</code>被持有后，它将处于锁定状态。线程执行到<code>monitorenter</code>指令时，将会尝试获取对象所对应的<code>monitor</code>的所有权，即尝试获得对象的锁。线程执行到<code>monitorexit</code>指令时，将会释放对象所对应的<code>monitor</code>的所有权。</p>
<p>举个具体的例子看下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态同步方法开始"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"静态同步方法结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实例同步方法开始"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"实例同步方法结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实例同步方法2开始"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">"实例同步方法2结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"同步代码块方法3开始"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">"同步代码块方法3结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SynchronizedDemo synDemo = <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               synDemo.method();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                synDemo.method2();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>javac SynchronizedDemo.java</code>编译一下，然后使用<code>javap -v SynchronizedDemo</code>反编译class文件，可以看到行号、本地变量表信息、反编译汇编代码，还会输出当前类用到的常量池等信息。</p>
<p>我们看一下反编译之后的同步方法与同步代码块</p>
<ol>
<li><p>同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.InterruptedException</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #11                 // String 实例同步方法2开始</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: ldc2_w        #12                 // long 3000l</span><br><span class="line">        11: invokestatic  #7                  // Method java/lang/Thread.sleep:(J)V</span><br><span class="line">        14: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        17: ldc           #14                 // String 实例同步方法2结束</span><br><span class="line">        19: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">14</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">22</span></span><br><span class="line">    Exceptions:</span><br><span class="line">      <span class="keyword">throws</span> java.lang.InterruptedException</span><br></pre></td></tr></table></figure>
<p>可以看到，同步方法<code>flags</code>包含一个<code>ACC_SYNCHCRONIZED</code>标记符<br>区别于同步代码块的监视器实现，同步方法通过使用 <code>ACC_SYNCHRONIZED</code> 标记符隐示的实现<br>原理是通过方法调用指令检查该方法在常量池中是否包含 <code>ACC_SYNCHRONIZED</code> 标记符，如果有，JVM 要求线程在调用之前请求锁</p>
</li>
<li><p>同步代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.InterruptedException</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter</span><br><span class="line">         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         7: ldc           #15                 // String 同步代码块方法3开始</span><br><span class="line">         9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        12: ldc2_w        #12                 // long 3000l</span><br><span class="line">        15: invokestatic  #7                  // Method java/lang/Thread.sleep:(J)V</span><br><span class="line">        18: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        21: ldc           #16                 // String 同步代码块方法3结束</span><br><span class="line">        23: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">26</span>: aload_1</span><br><span class="line">        <span class="number">27</span>: monitorexit</span><br><span class="line">        <span class="number">28</span>: goto          <span class="number">36</span></span><br><span class="line">        <span class="number">31</span>: astore_2</span><br><span class="line">        <span class="number">32</span>: aload_1</span><br><span class="line">        <span class="number">33</span>: monitorexit</span><br><span class="line">        <span class="number">34</span>: aload_2</span><br><span class="line">        <span class="number">35</span>: athrow</span><br><span class="line">        <span class="number">36</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">4</span>    <span class="number">28</span>    <span class="number">31</span>   any</span><br><span class="line">            <span class="number">31</span>    <span class="number">34</span>    <span class="number">31</span>   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">19</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">18</span></span><br><span class="line">        line <span class="number">23</span>: <span class="number">26</span></span><br><span class="line">        line <span class="number">25</span>: <span class="number">36</span></span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">          offset_delta = <span class="number">31</span></span><br><span class="line">          locals = [ class SynchronizedDemo, class java/lang/Object ]</span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">4</span></span><br><span class="line">    Exceptions:</span><br><span class="line">      <span class="keyword">throws</span> java.lang.InterruptedException</span><br></pre></td></tr></table></figure>
<p>可以看到，在<code>flags</code>中没有了<code>ACC_SYNCHCRONIZED</code>标记符，并且在<code>Code</code>中包含了<code>monitorenter</code>和<code>monitorexit</code>，并且<code>monitorenter</code>在同步代码开始之前，<code>monitorexit</code>在同步代码结束之后。（可以看到，里面有两次<code>monitorexit</code>，这是因为第1次为同步正常退出释放锁；第2次为发生异步退出释放锁；这上面锁住的就是this。）</p>
</li>
</ol>
<p>简单说明一下<code>monitorenter</code>和<code>monitorexit</code></p>
<ol>
<li><p>monitorenter：每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
<ul>
<li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</li>
<li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1；（只有首先获得锁的线程才能允许继续获取多个锁）</li>
<li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</li>
</ul>
</li>
<li><p>monitorexit：执行monitorexit指令的线程必须是对象实例所对应的监视器的所有者，指令执行时，线程会先将进入次数-1，若-1之后进入次数变成0，则线程退出监视器(即释放锁)，其他阻塞在该监视器的线程可以重新竞争该监视器的所有权</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/14/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-volatitle%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/14/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-volatitle%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">Java并发编程（五）之线程安全问题-volatitle关键字</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-14 19:36:40" itemprop="dateCreated datePublished" datetime="2019-12-14T19:36:40+08:00">2019-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-15 14:34:18" itemprop="dateModified" datetime="2020-05-15T14:34:18+08:00">2020-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇提到了共享变量的线程安全问题，我们使用<code>synchronized</code>关键字来保证了共享变量的线程安全，这次我们来看看<code>volatitle</code>关键字。</p>
<p>当一个变量被声明为<code>volatitle</code>时，线程在写入变量的时候就不会把值缓存在寄存器或者一级二级缓存（Java内存模型中的工作内存），而是直接刷新回主内存，当其他线程读取该共享变量时，会从主内存直接获取最新的值，而不是从自己的工作内存中获取变量值。</p>
<p>我们看看如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoiatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VoiatileTestRunable myRunable = <span class="keyword">new</span> VoiatileTestRunable();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(myRunable,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myRunable,<span class="string">"t2"</span>).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VoiatileTestRunable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                sale();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            --count;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">",出售第"</span> + (<span class="number">5</span> - count) + <span class="string">"张票"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t1,出售第<span class="number">1</span>张票</span><br><span class="line">t2,出售第<span class="number">1</span>张票</span><br><span class="line">t1,出售第<span class="number">3</span>张票</span><br><span class="line">t2,出售第<span class="number">3</span>张票</span><br><span class="line">t1,出售第<span class="number">5</span>张票</span><br><span class="line">t2,出售第<span class="number">5</span>张票</span><br></pre></td></tr></table></figure>

<p>可以看到，执行结果并不是我们预期的结果，一共卖出去<code>6</code>张票，但是count变量没有累加到6，这是由于<code>volatitle</code>只保证了内存可见性，但却没有保证操作的原子性，<code>++</code>，<code>--</code>操作都不是原子性的。</p>
<p>那么如何保证操作原子性呢，我们可以使用Java中提供的原子类<code>AtomicInteger</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.constantine.daily.concurrency.atomicobj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoiatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VoiatileTestRunable myRunable = <span class="keyword">new</span> VoiatileTestRunable();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(myRunable,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myRunable,<span class="string">"t2"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VoiatileTestRunable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((cnt =count.getAndDecrement())&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">",出售第"</span> + ((<span class="number">5</span> - cnt)+<span class="number">1</span>) + <span class="string">"张票"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t2,出售第<span class="number">2</span>张票</span><br><span class="line">t1,出售第<span class="number">1</span>张票</span><br><span class="line">t1,出售第<span class="number">4</span>张票</span><br><span class="line">t2,出售第<span class="number">3</span>张票</span><br><span class="line">t1,出售第<span class="number">5</span>张票</span><br></pre></td></tr></table></figure>
<p>可以看到，一共卖出去5张票，因为AtomicInteger 保证了操作原子性。还可以注意到，count变量并没有从1逐一累加到5，这是因为虽然<code>count.getAndDecrement()</code>是原子操作，但是<code>sale</code>方法中if语句里的代码块并不是原子操作。两个线程同时执行打印语句，就会出现这种情况，但是对卖票这件事情没有什么影响，不会出现卖超的情况。</p>
<p>通过上面代码我们了解到，<code>volatile</code>虽然提供了可见性保证，但是并没有保证操作的原子性。</p>
<p>那么在什么情况下可以使用volatile关键字呢？</p>
<ol>
<li>写入变量不依赖变量当前值时。如果依赖当前值，将是 <code>获取-计算-写入</code> 三步操作（上述代码中的–count，此操作依赖于count的当前值），这三步操作不是原子性的，而volatile不保证原子性</li>
<li>读写变量值时没有加锁。因为加锁本身已经保证了内存可见性，这时候不需要再将变量声明为volatile了</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Java并发编程（四）之线程安全问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-24 19:24:41" itemprop="dateCreated datePublished" datetime="2019-11-24T19:24:41+08:00">2019-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-25 22:28:58" itemprop="dateModified" datetime="2019-11-25T22:28:58+08:00">2019-11-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>讲完创建线程的方法，接下来我们学习一下多线程编程中会遇到的线程安全问题。</p>
<p>谈到线程安全，就会涉及到共享资源，所谓共享资源，就是指该资源被多个线程使用。线程安全问题就是，当多个线程同时读写同一个共享资源的时候，没有加任何同步措施，导致出现脏数据，以及预料之外的结果。</p>
<p>例如下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThreadSafeTest thread1 = <span class="keyword">new</span> MyThreadSafeTest();</span><br><span class="line">        MyThreadSafeTest thread2 = <span class="keyword">new</span> MyThreadSafeTest();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadSafeTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">while</span>(ThreadSafeTest.count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                sale();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ThreadSafeTest.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            --ThreadSafeTest.count;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">",出售第"</span> + (<span class="number">5</span> - ThreadSafeTest.count) + <span class="string">"张票"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">1</span>,出售第<span class="number">2</span>张票</span><br><span class="line">Thread-<span class="number">0</span>,出售第<span class="number">2</span>张票</span><br><span class="line">Thread-<span class="number">1</span>,出售第<span class="number">3</span>张票</span><br><span class="line">Thread-<span class="number">0</span>,出售第<span class="number">4</span>张票</span><br><span class="line">Thread-<span class="number">1</span>,出售第<span class="number">5</span>张票</span><br></pre></td></tr></table></figure>

<p>我们模拟了多窗口售票的问题，每个线程就是一个窗口。可以看到，会出现一张票卖出多次的情况，这显然是不合理的。</p>
<p>这是由于什么原因导致的呢？要查找其原因，首先我们需要了解Java的内存模型。如下图：</p>
<p><img src="/pic_doc/java_mem_model.jpg" alt="Java内存模型"> </p>
<p>Java内存模型规定，将所有的变量都放在主内存中，当线程使用变量的时候从主内存中将变量复制一份到自己的工作空间或者说工作内存，线程读写变量时操作的是自己工作内存中的变量。</p>
<p>Java内存模型是一个抽象的概念，实际实现中的工作内存是什么样子呢？</p>
<p><img src="/pic_doc/cpu_mem_model.jpg" alt=""> </p>
<p>图中所示是一个双核CPU的架构，Java内存模型里面的工作内存就对应这里的L1或者L2或者CPU的寄存器。</p>
<p>当一个线程操作共享变量时，它首先从主内存复制共享变量到自己的工作内存，对工作内存里的变量进行处理，处理完后将变最值更新到主内存。</p>
<p>那么假如线程A和线程B同时处理一个共享变量，会出现什么情况？我们使用图中所示CPU架构，假设线程A和线程B使用不同CPU执行，并且当前两级Cache都为空。那么这时候由于Cache的存在，将会导致内存不可见问题，具体看下面的分析。</p>
<ol>
<li>线程A首先获取共享变量X的值，由于两级Cache都没有命中，所以加教木中X的值，假如为0。然后把X=0的值缓存到两级缓存，线程A修改X的值为1，然后将其写入两级Cache，并且刷新到主内存。线程A操作完毕后，线程A所在CPU的两级Cache内和主内存里面的X的值都是1。</li>
<li>线程B获取X的值，首先一级缓存没有命中，然后看二级缓存，二级缓存命的所以返回X=1，到这里一切都是正常的，因为这时候主内存中也是X=1。然后线程B修改X的值为2,并将其存放线程B所在的一级Cache和共享二级Cache中，最后更新主内存中X的值为2，到这里一切都是好的。</li>
<li>线程A这次又需要修改X的值，获取时一级缓存命中，并且X=1，到这里问题与出现了，明明线程B已经把X的值修改为了2，为何线程A获取的还是1呢？这就是共享变量的内存不可见问题，也就是线程B写入的值对线程A不可见。</li>
</ol>
<p>了解了这些，我们就会明白，上述代码中，一张票卖多次的问题是如何导致的了，就是因为<code>thread1</code>与<code>thread2</code>由于内存模型导致的共享变量<code>count</code>内存不可见。</p>
<p>那么如何解决呢？</p>
<p>大学时候我们学过使用<code>synchronized</code>加锁来解决线程安全问题，例如上述卖票代码改为如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String lock = <span class="string">"lock"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThreadSafeTest thread1 = <span class="keyword">new</span> MyThreadSafeTest();</span><br><span class="line">        MyThreadSafeTest thread2 = <span class="keyword">new</span> MyThreadSafeTest();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadSafeTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">while</span>(ThreadSafeTest.count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                sale();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(ThreadSafeTest.lock)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ThreadSafeTest.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                --ThreadSafeTest.count;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">",出售第"</span> + (<span class="number">5</span> - ThreadSafeTest.count) + <span class="string">"张票"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>,出售第<span class="number">1</span>张票</span><br><span class="line">Thread-<span class="number">1</span>,出售第<span class="number">2</span>张票</span><br><span class="line">Thread-<span class="number">0</span>,出售第<span class="number">3</span>张票</span><br><span class="line">Thread-<span class="number">1</span>,出售第<span class="number">4</span>张票</span><br><span class="line">Thread-<span class="number">0</span>,出售第<span class="number">5</span>张票</span><br></pre></td></tr></table></figure>

<p>我们对卖票的操作进行了加锁，加锁之后，就没有出现共享变量混乱的问题，那么<code>synchronized</code>到底是什么呢？怎么实现的共享变量内存可见呢？</p>
<p><code>synchronized</code>块是Java提供的一种原子性内置锁，Java中的每个对象都可以把它当做一个同步锁来使用，这些Java内置的使用者看不到的锁被称为内部锁，也叫作监视器锁，线程的执行代码在进入<code>synchronized</code>代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。拿到内部锁的线程会在正常退出同步代码块或者抛出异常后或者在同步块内调用了该内置锁资源的<code>wait</code>系列方法时释放该内置锁。内置锁是排它锁，也就是当一个线程获取这个锁后，其他线程必须等待该线程释放锁后才能获取该锁。</p>
<p>由于共享变量内存可见性问题主要是由于线程的工作内存导致的，使用<code>synchronized</code>的时候，它的内存语义是什么样的呢？（也就是加锁和释放锁的语义）。</p>
<p>进入<code>synchronized</code>块的内存语义（加锁）是把在<code>synchronized</code>共内使用到的共享变量从线程的工作内存中清除，这样在<code>synchronized</code>块内使用到该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取。退出<code>synchronized</code>块的内存语义（释放锁）是把在<code>synchronized</code>块内对共享变量的修改刷新到主内存。</p>
<p>除可以解决共享变量内存可见性问题外，synchronized 经常被用来实现原子性操作。另外请注意，synchronized 关键字会引起线程上下文切换并带来线程调度开销，所以使用锁太笨重，尤其是在Java1.6之前，没有对synchronized进行优化。对于内存可见性的问题，Java还提供了一种弱同步，也就是使用 <code>volatile</code> 关键字，这个由于篇幅问题，下一篇文章再讲吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Java并发编程（三）之线程池的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-24 16:40:14 / Modified: 19:20:11" itemprop="dateCreated datePublished" datetime="2019-11-24T16:40:14+08:00">2019-11-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前我们在如何创建线程的文章中介绍到了线程池创建线程，接下来学习一下如何使用线程池创建线程。</p>
<p>Java通过Executors提供四种常用线程池，这四种线程池都是通过<code>ThreadPoolExecutor</code>实现的，我们来看一下其构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法内具体的逻辑我们先忽略，先来看看构造方法的参数含义：</p>
<ol>
<li>corePoolSize: 线程池核心线程个数</li>
<li>maximumPoolSize： 线程池最大线程个数</li>
<li>keepAliveTime： 线程存活时间，指的是如果当前线程池中的线程数量比核心线程数量多，并且是闲置状态，则这些闲置线程能存活的最大时间</li>
<li>unit： 存活时间的时间单位</li>
<li>workQueue： 用于保存等待执行的任务的阻塞队列，比如基于数组的有界队列<code>ArrayBlockingQueue</code>，基于链表的<code>LinkedBlockingQueue</code>等</li>
<li>threadFactory： 创建线程的工厂</li>
<li>handler： 拒绝策略，当队列满了，并且线程个数达到maximumPoolSize后采取的拒绝策略</li>
</ol>
<p><code>Executors</code>中创建线程池的方法其实就是通过使用<code>ThreadPoolExecutor</code>构造方法的不同参数来创建不同类型的线程池 </p>
<p>接下来我们深入源码看一看<code>Executors</code>中创建线程池的方法，它是如何使用<code>ThreadPoolExecutor</code>来创建线程池的</p>
<ol>
<li>单线程化线程池（SingleThreadExecutor）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特点：创建一个核心线程个数和最大线程个数都为1的线程池，并且阻塞队列长度为Integer.MAX_VALUE。keepAliveTime为0说明只要线程个数比核心线程数多并且当前空闲则回收。</li>
<li>应用场景：不适合并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作、文件操作等。</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">    singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(index);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>可以看到，index的值是递增的，因为只有一个线程在执行任务</p>
<ol start="2">
<li>定长线程池（FixedThreadPool）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特点：只有核心线程，线程数量固定（其<code>corePoolSize</code>和<code>maximumPoolSize</code>值相同），执行完立即回收（<code>keepAliveTime</code>为0），阻塞队列长度为Integer.MAX_VALUE。</li>
<li>应用场景：控制线程最大并发数。</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line"></span><br><span class="line">    fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(index);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>可以看到，index的值不是递增的，因为只有三个线程在执行任务</p>
<ol start="3">
<li>可缓存线程池（CachedThreadPool）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特点：无核心线程，非核心线程数量无限，执行完闲置60s后回收，这个类型的特殊之处在于，加入同步队列的任务会被马上执行，同步队列里面最多只有一个任务（因为每来一个任务就会马上创建一个线程来执行）</li>
<li>应用场景：执行大量、耗时少的任务。</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">    cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(index);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>可以看到，index的值不是递增的，原因与上一个相同。</p>
<ol start="4">
<li>定时线程池（ScheduledThreadPool）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>注：这个与上面三个有点区别，这是使用的是<code>ScheduledThreadPoolExecutor</code>创建的，此类继承<code>ThreadPoolExecutor</code>类。</p>
</li>
<li><p>特点：核心线程数量固定，非核心线程数量无限，执行完闲置10ms后回收，任务队列为延时阻塞队列。</p>
</li>
<li><p>应用场景：执行定时或周期性的任务。</p>
</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"delay 3 seconds"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>执行结果：<br>    延迟3秒后打印出<code>delay 3 seconds</code></p>
<p>下面我们来用代码具体看下，这些线程池的区别</p>
<ol>
<li>单线程化线程池（SingleThreadExecutor）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个单线程的线程池  </span></span><br><span class="line">ExecutorService pool = Executors.newSingleThreadExecutor();  </span><br><span class="line"><span class="comment">// 创建线程  </span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t2 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t3 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t4 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t5 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line"><span class="comment">// 将线程放入池中进行执行  </span></span><br><span class="line">pool.execute(t1);  </span><br><span class="line">pool.execute(t2);  </span><br><span class="line">pool.execute(t3);  </span><br><span class="line">pool.execute(t4);  </span><br><span class="line">pool.execute(t5);  </span><br><span class="line"><span class="comment">// 关闭线程池  </span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br></pre></td></tr></table></figure>

<p>通过执行结果我们可以看到，虽然我们在线程池中放了5个线程，但是由于线程池是单线程池，所以只有第一个线程存在于线程池中。<br>每次调用execute方法，其实最后都是调用了thread-1的run方法。</p>
<ol start="2">
<li>定长线程池（FixedThreadPool）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 创建线程  </span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t2 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t3 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t4 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t5 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line"><span class="comment">// 将线程放入池中进行执行  </span></span><br><span class="line">pool.execute(t1);  </span><br><span class="line">pool.execute(t2);  </span><br><span class="line">pool.execute(t3);  </span><br><span class="line">pool.execute(t4);  </span><br><span class="line">pool.execute(t5);  </span><br><span class="line"><span class="comment">// 关闭线程池  </span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>正在执行。。。</span><br></pre></td></tr></table></figure>

<p>将<code>Executors.newFixedThreadPool(5)</code>中的<code>5</code>改为<code>2</code>再试试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行。。。</span><br></pre></td></tr></table></figure>

<p>从以上结果可以看出，newFixedThreadPool的参数指定了可以运行的线程的最大数目，超过这个数目的线程加进去以后，不会运行。其次，加入线程池的线程属于托管状态，线程的运行不受加入顺序的影响。</p>
<ol start="3">
<li>可缓存线程池（CachedThreadPool）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 创建线程  </span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t2 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t3 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t4 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t5 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line"><span class="comment">// 将线程放入池中进行执行  </span></span><br><span class="line">pool.execute(t1);  </span><br><span class="line">pool.execute(t2);  </span><br><span class="line">pool.execute(t3);  </span><br><span class="line">pool.execute(t4);  </span><br><span class="line">pool.execute(t5);  </span><br><span class="line"><span class="comment">// 关闭线程池  </span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>正在执行。。。</span><br></pre></td></tr></table></figure>

<p>这种方式的特点是：可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。</p>
<ol start="4">
<li>定时线程池（ScheduledThreadPool）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ScheduledThreadPoolExecutor exec = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>);</span><br><span class="line">exec.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">exec.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(System.nanoTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">================</span><br><span class="line"><span class="number">233471023732097</span></span><br><span class="line"><span class="number">233473026158692</span></span><br><span class="line"><span class="number">233475023768285</span></span><br><span class="line">================</span><br><span class="line"><span class="number">233477030024240</span></span><br><span class="line"><span class="number">233479027432148</span></span><br><span class="line">================</span><br><span class="line"><span class="number">233481026928538</span></span><br><span class="line"><span class="number">233483025530535</span></span><br><span class="line"><span class="number">233485025312657</span></span><br><span class="line">================</span><br></pre></td></tr></table></figure>

<p>可以看到，两个任务互不影响</p>
<p>上面的代码建议大家亲自执行以下，会有更深的体会。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">猫屎咖啡</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SheldonKubor" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SheldonKubor" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:mjh123877@163.com" title="E-Mail → mailto:mjh123877@163.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">猫屎咖啡</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

</body>
</html>
