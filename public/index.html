<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="nPoziOQzb5Lb3pPO9SGvdEUa54TVyk1_z_kbLwqQ7r0">








  <meta name="baidu-site-verification" content="FAhxzOEgJW">







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="猫屎咖啡">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="猫屎咖啡">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="猫屎咖啡">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>猫屎咖啡</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">猫屎咖啡</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/24/Java并发编程（四）之线程安全问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/24/Java并发编程（四）之线程安全问题/" itemprop="url">Java并发编程（四）之线程安全问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-24T19:24:41+08:00">
                2019-11-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>讲完创建线程的方法，接下来我们学习一下多线程编程中会遇到的线程安全问题。</p>
<p>谈到线程安全，就会涉及到共享资源，所谓共享资源，就是指该资源被多个线程使用。线程安全问题就是，当多个线程同时读写同一个共享资源的时候，没有加任何同步措施，导致出现脏数据，以及预料之外的结果。</p>
<p>例如下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThreadSafeTest thread1 = <span class="keyword">new</span> MyThreadSafeTest();</span><br><span class="line">        MyThreadSafeTest thread2 = <span class="keyword">new</span> MyThreadSafeTest();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadSafeTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">while</span>(ThreadSafeTest.count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                sale();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ThreadSafeTest.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            --ThreadSafeTest.count;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">",出售第"</span> + (<span class="number">5</span> - ThreadSafeTest.count) + <span class="string">"张票"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">1</span>,出售第<span class="number">2</span>张票</span><br><span class="line">Thread-<span class="number">0</span>,出售第<span class="number">2</span>张票</span><br><span class="line">Thread-<span class="number">1</span>,出售第<span class="number">3</span>张票</span><br><span class="line">Thread-<span class="number">0</span>,出售第<span class="number">4</span>张票</span><br><span class="line">Thread-<span class="number">1</span>,出售第<span class="number">5</span>张票</span><br></pre></td></tr></table></figure>

<p>我们模拟了多窗口售票的问题，每个线程就是一个窗口。可以看到，会出现一张票卖出多次的情况，这显然是不合理的。</p>
<p>这是由于什么原因导致的呢？要查找其原因，首先我们需要了解Java的内存模型。如下图：</p>
<p><img src="/pic_doc/java_mem_model.jpg" alt="Java内存模型"> </p>
<p>Java内存模型规定，将所有的变量都放在主内存中，当线程使用变量的时候从主内存中将变量复制一份到自己的工作空间或者说工作内存，线程读写变量时操作的是自己工作内存中的变量。</p>
<p>Java内存模型是一个抽象的概念，实际实现中的工作内存是什么样子呢？</p>
<p><img src="/pic_doc/cpu_mem_model.jpg" alt> </p>
<p>图中所示是一个双核CPU的架构，Java内存模型里面的工作内存就对应这里的L1或者L2或者CPU的寄存器。</p>
<p>当一个线程操作共享变量时，它首先从主内存复制共享变量到自己的工作内存，对工作内存里的变量进行处理，处理完后将变最值更新到主内存。</p>
<p>那么假如线程A和线程B同时处理一个共享变量，会出现什么情况？我们使用图中所示CPU架构，假设线程A和线程B使用不同CPU执行，并且当前两级Cache都为空。那么这时候由于Cache的存在，将会导致内存不可见问题，具体看下面的分析。</p>
<ol>
<li>线程A首先获取共享变量X的值，由于两级Cache都没有命中，所以加教木中X的值，假如为0。然后把X=0的值缓存到两级缓存，线程A修改X的值为1，然后将其写入两级Cache，并且刷新到主内存。线程A操作完毕后，线程A所在CPU的两级Cache内和主内存里面的X的值都是1。</li>
<li>线程B获取X的值，首先一级缓存没有命中，然后看二级缓存，二级缓存命的所以返回X=1，到这里一切都是正常的，因为这时候主内存中也是X=1。然后线程B修改X的值为2,并将其存放线程B所在的一级Cache和共享二级Cache中，最后更新主内存中X的值为2，到这里一切都是好的。</li>
<li>线程A这次又需要修改X的值，获取时一级缓存命中，并且X=1，到这里问题与出现了，明明线程B已经把X的值修改为了2，为何线程A获取的还是1呢？这就是共享变量的内存不可见问题，也就是线程B写入的值对线程A不可见。</li>
</ol>
<p>了解了这些，我们就会明白，上述代码中，一张票卖多次的问题是如何导致的了，就是因为<code>thread1</code>与<code>thread2</code>由于内存模型导致的共享变量<code>count</code>内存不可见。</p>
<p>那么如何解决呢？</p>
<p>大学时候我们学过使用<code>synchronized</code>加锁来解决线程安全问题，例如上述卖票代码改为如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String lock = <span class="string">"lock"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThreadSafeTest thread1 = <span class="keyword">new</span> MyThreadSafeTest();</span><br><span class="line">        MyThreadSafeTest thread2 = <span class="keyword">new</span> MyThreadSafeTest();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadSafeTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">while</span>(ThreadSafeTest.count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                sale();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(ThreadSafeTest.lock)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ThreadSafeTest.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                --ThreadSafeTest.count;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">",出售第"</span> + (<span class="number">5</span> - ThreadSafeTest.count) + <span class="string">"张票"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>,出售第<span class="number">1</span>张票</span><br><span class="line">Thread-<span class="number">1</span>,出售第<span class="number">2</span>张票</span><br><span class="line">Thread-<span class="number">0</span>,出售第<span class="number">3</span>张票</span><br><span class="line">Thread-<span class="number">1</span>,出售第<span class="number">4</span>张票</span><br><span class="line">Thread-<span class="number">0</span>,出售第<span class="number">5</span>张票</span><br></pre></td></tr></table></figure>

<p>我们对卖票的操作进行了加锁，加锁之后，就没有出现共享变量混乱的问题，那么<code>synchronized</code>到底是什么呢？怎么实现的共享变量内存可见呢？</p>
<p><code>synchronized</code>块是Java提供的一种原子性内置锁，Java中的每个对象都可以把它当做一个同步锁来使用，这些Java内置的使用者看不到的锁被称为内部锁，也叫作监视器锁，线程的执行代码在进入<code>synchronized</code>代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。拿到内部锁的线程会在正常退出同步代码块或者抛出异常后或者在同步块内调用了该内置锁资源的<code>wait</code>系列方法时释放该内置锁。内置锁是排它锁，也就是当一个线程获取这个锁后，其他线程必须等待该线程释放锁后才能获取该锁。</p>
<p>由于共享变量内存可见性问题主要是由于线程的工作内存导致的，使用<code>synchronized</code>的时候，它的内存语义是什么样的呢？（也就是加锁和释放锁的语义）。</p>
<p>进入<code>synchronized</code>块的内存语义（加锁）是把在<code>synchronized</code>共内使用到的共享变量从线程的工作内存中清除，这样在<code>synchronized</code>块内使用到该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取。退出<code>synchronized</code>块的内存语义（释放锁）是把在<code>synchronized</code>块内对共享变量的修改刷新到主内存。</p>
<p>除可以解决共享变量内存可见性问题外，synchronized 经常被用来实现原子性操作。另外请注意，synchronized 关键字会引起线程上下文切换并带来线程调度开销，所以使用锁太笨重，尤其是在Java1.6之前，没有对synchronized进行优化。对于内存可见性的问题，Java还提供了一种弱同步，也就是使用 <code>volatile</code> 关键字，这个由于篇幅问题，下一篇文章再讲吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/24/Java并发编程（三）之线程池的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/24/Java并发编程（三）之线程池的使用/" itemprop="url">Java并发编程（三）之线程池的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-24T16:40:14+08:00">
                2019-11-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前我们在如何创建线程的文章中介绍到了线程池创建线程，接下来学习一下如何使用线程池创建线程。</p>
<p>Java通过Executors提供四种常用线程池，这四种线程池都是通过<code>ThreadPoolExecutor</code>实现的，我们来看一下其构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法内具体的逻辑我们先忽略，先来看看构造方法的参数含义：</p>
<ol>
<li>corePoolSize: 线程池核心线程个数</li>
<li>maximumPoolSize： 线程池最大线程个数</li>
<li>keepAliveTime： 线程存活时间，指的是如果当前线程池中的线程数量比核心线程数量多，并且是闲置状态，则这些闲置线程能存活的最大时间</li>
<li>unit： 存活时间的时间单位</li>
<li>workQueue： 用于保存等待执行的任务的阻塞队列，比如基于数组的有界队列<code>ArrayBlockingQueue</code>，基于链表的<code>LinkedBlockingQueue</code>等</li>
<li>threadFactory： 创建线程的工厂</li>
<li>handler： 拒绝策略，当队列满了，并且线程个数达到maximumPoolSize后采取的拒绝策略</li>
</ol>
<p><code>Executors</code>中创建线程池的方法其实就是通过使用<code>ThreadPoolExecutor</code>构造方法的不同参数来创建不同类型的线程池 </p>
<p>接下来我们深入源码看一看<code>Executors</code>中创建线程池的方法，它是如何使用<code>ThreadPoolExecutor</code>来创建线程池的</p>
<ol>
<li>单线程化线程池（SingleThreadExecutor）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特点：创建一个核心线程个数和最大线程个数都为1的线程池，并且阻塞队列长度为Integer.MAX_VALUE。keepAliveTime为0说明只要线程个数比核心线程数多并且当前空闲则回收。</li>
<li>应用场景：不适合并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作、文件操作等。</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">    singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(index);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>可以看到，index的值是递增的，因为只有一个线程在执行任务</p>
<ol start="2">
<li>定长线程池（FixedThreadPool）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特点：只有核心线程，线程数量固定（其<code>corePoolSize</code>和<code>maximumPoolSize</code>值相同），执行完立即回收（<code>keepAliveTime</code>为0），阻塞队列长度为Integer.MAX_VALUE。</li>
<li>应用场景：控制线程最大并发数。</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line"></span><br><span class="line">    fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(index);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>可以看到，index的值不是递增的，因为只有三个线程在执行任务</p>
<ol start="3">
<li>可缓存线程池（CachedThreadPool）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特点：无核心线程，非核心线程数量无限，执行完闲置60s后回收，这个类型的特殊之处在于，加入同步队列的任务会被马上执行，同步队列里面最多只有一个任务（因为每来一个任务就会马上创建一个线程来执行）</li>
<li>应用场景：执行大量、耗时少的任务。</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">    cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(index);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>可以看到，index的值不是递增的，原因与上一个相同。</p>
<ol start="4">
<li>定时线程池（ScheduledThreadPool）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注：这个与上面三个有点区别，这是使用的是<code>ScheduledThreadPoolExecutor</code>创建的，此类继承<code>ThreadPoolExecutor</code>类。</p>
</li>
<li><p>特点：核心线程数量固定，非核心线程数量无限，执行完闲置10ms后回收，任务队列为延时阻塞队列。</p>
</li>
<li><p>应用场景：执行定时或周期性的任务。</p>
</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"delay 3 seconds"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>执行结果：<br>    延迟3秒后打印出<code>delay 3 seconds</code></p>
<p>下面我们来用代码具体看下，这些线程池的区别</p>
<ol>
<li>单线程化线程池（SingleThreadExecutor）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个单线程的线程池  </span></span><br><span class="line">ExecutorService pool = Executors.newSingleThreadExecutor();  </span><br><span class="line"><span class="comment">// 创建线程  </span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t2 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t3 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t4 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t5 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line"><span class="comment">// 将线程放入池中进行执行  </span></span><br><span class="line">pool.execute(t1);  </span><br><span class="line">pool.execute(t2);  </span><br><span class="line">pool.execute(t3);  </span><br><span class="line">pool.execute(t4);  </span><br><span class="line">pool.execute(t5);  </span><br><span class="line"><span class="comment">// 关闭线程池  </span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br></pre></td></tr></table></figure>

<p>通过执行结果我们可以看到，虽然我们在线程池中放了5个线程，但是由于线程池是单线程池，所以只有第一个线程存在于线程池中。<br>每次调用execute方法，其实最后都是调用了thread-1的run方法。</p>
<ol start="2">
<li>定长线程池（FixedThreadPool）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 创建线程  </span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t2 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t3 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t4 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t5 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line"><span class="comment">// 将线程放入池中进行执行  </span></span><br><span class="line">pool.execute(t1);  </span><br><span class="line">pool.execute(t2);  </span><br><span class="line">pool.execute(t3);  </span><br><span class="line">pool.execute(t4);  </span><br><span class="line">pool.execute(t5);  </span><br><span class="line"><span class="comment">// 关闭线程池  </span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>正在执行。。。</span><br></pre></td></tr></table></figure>

<p>将<code>Executors.newFixedThreadPool(5)</code>中的<code>5</code>改为<code>2</code>再试试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行。。。</span><br></pre></td></tr></table></figure>

<p>从以上结果可以看出，newFixedThreadPool的参数指定了可以运行的线程的最大数目，超过这个数目的线程加进去以后，不会运行。其次，加入线程池的线程属于托管状态，线程的运行不受加入顺序的影响。</p>
<ol start="3">
<li>可缓存线程池（CachedThreadPool）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 创建线程  </span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t2 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t3 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t4 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line">Thread t5 = <span class="keyword">new</span> MyThreadPoolTest();  </span><br><span class="line"><span class="comment">// 将线程放入池中进行执行  </span></span><br><span class="line">pool.execute(t1);  </span><br><span class="line">pool.execute(t2);  </span><br><span class="line">pool.execute(t3);  </span><br><span class="line">pool.execute(t4);  </span><br><span class="line">pool.execute(t5);  </span><br><span class="line"><span class="comment">// 关闭线程池  </span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>正在执行。。。</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>正在执行。。。</span><br></pre></td></tr></table></figure>

<p>这种方式的特点是：可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。</p>
<ol start="4">
<li>定时线程池（ScheduledThreadPool）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ScheduledThreadPoolExecutor exec = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>);</span><br><span class="line">exec.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"================"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">exec.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(System.nanoTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">================</span><br><span class="line"><span class="number">233471023732097</span></span><br><span class="line"><span class="number">233473026158692</span></span><br><span class="line"><span class="number">233475023768285</span></span><br><span class="line">================</span><br><span class="line"><span class="number">233477030024240</span></span><br><span class="line"><span class="number">233479027432148</span></span><br><span class="line">================</span><br><span class="line"><span class="number">233481026928538</span></span><br><span class="line"><span class="number">233483025530535</span></span><br><span class="line"><span class="number">233485025312657</span></span><br><span class="line">================</span><br></pre></td></tr></table></figure>

<p>可以看到，两个任务互不影响</p>
<p>上面的代码建议大家亲自执行以下，会有更深的体会。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/17/MySQL优化（一）之简单介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/17/MySQL优化（一）之简单介绍/" itemprop="url">MySQL优化（一）之简单介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-17T17:40:13+08:00">
                2019-11-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>做后端开发的同学们免不了接触MySQL，虽然现在有很多ORM框架，但是个人认为，在一些情况下还是需要我们手工写SQL的，个人也比较喜欢手写SQL，可能是做过半年数据分析类工作的原因吧。而能够手写SQL查询出我们想要的数据只是一个合格后端开发工程师的基本素质，我们还得学习如何优化我们的SQL，虽然现在很多大公司都有DBA这个职位，但是我们做后端开发的多了解一些SQL优化的知识也是很有帮助的。</p>
<p>说到数据库优化，我们最常遇到的就是查询优化，而最常用的查询优化手段就是建立索引。还有就是在建库建表的时候就要做好的库表结构优化。</p>
<p>查询优化，索引优化，库表结构优化需要齐头并进，一个不落。这三者相辅相成，在获得编写sql查询优化的经验的同时，我们也会学习到如何为高效的查询设计表结构以及索引，同样的，也可以学习到优化库表结构时将会影响到那些类型的查询。</p>
<p>一条sql语句为什么需要优化？那绝对是因为它的查询速度慢，那么为什么查询速度会慢呢？</p>
<p>查询性能低下最基本的原因就是访问的数据太多。某些查询了能不可避免的需要筛选大量数据，但这种情况不常见。大部分性能低下的查询都可以通过减少访问数据量的方式进行优化。对于低效的查询，我们首先可以通过以下两个步骤来分析：</p>
<pre><code>1. 确认应用程序是够在检索大量超过我们实际需要的数据。这通常意味着我们访问了太多的行或者列。
2. 确认MySQL服务层是够在分析大量超过需要的数据行。</code></pre><p>知道了从哪方面入手，那么就会知道如何优化了</p>
<p>第一，访问太多行或者列的：</p>
<ol>
<li>若是访问太多行</li>
</ol>
<p>例如，在某个新闻网站中取出100条记录，但只是在页面上显示前10条。对于这种，最简单的就是在查询后面加上<code>limit</code>。</p>
<ol start="2">
<li>若是访问太多的列</li>
</ol>
<p>例如：我只想查询学生的名字，我们应该使用如下语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure>

<p>而不是使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure>

<p>这两个方法看起来很基础对不对，虽然基础，但是很有效。其实这也算不上什么优化，只是我们在开发中需要注意的细节问题。</p>
<p>另外需要注意的是，总是取出全部的列，会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的I/O、内存、CPU的消耗，因此，一些DBA是严格禁止使用<code>select *</code>这种写法的，这样做有时候还能避免某些列被修改带来的问题。</p>
<p>但是，查询返回超过需要的数据也并不总是坏事，作为后端开发深有体会的一点就是，这种浪费数据库资源的方式可以简化开发。例如，在现在前后端分离的开发中，前端所需要展示哪些字段的数据，都是我们后端查询之后再返回给他的，但是，前端展示的字段并不是一成不变的，并不是总是那几个字段，因为有时候产品需求会变更，比如，今天的需求是展示名字，性别。明天的需求就可能变为展示名字，性别，年龄，身高等等等等。这种情况下，我们就需要频繁的修改我们的代码以满足一天一变的产品需求（需求天天变对于开发来说很苦逼的）。由于经常有这种情况发生，所以一些开发人员就会直接使用<code>select *</code>这种写法，不是爱改需求吗，那我就我把数据都给你，你想展示什么自己挑着用吧。。这种方式虽然不满足优化的思想，但是确实简化了开发，但是我们也不能为了简化开发一味的使用<code>select *</code>，我们使用这种方式的前提是我们清楚这样做的性能影响。</p>
<p>第二，分析（扫描）了大量超过需要的数据行</p>
<p>在确定查询只返回需要的数据以后，接下来我们应该看看查询为了返回这些结果，是否扫描了过多的数据。在分析查询时，查看该查询扫描的行数是非常有帮助的，这也能在一定程度上说明该查询的效率高不高，也就是<code>所需行数/扫描行数</code>的比值高不高。这里我们就要使用到<code>explain</code>关键字了，其中<code>type</code>列反应了访问类型，从全表扫描到索引扫描，范围扫描，唯一索引查询，常数引用等等。这些速度从慢到快，扫描的行数也是从多到少。如果没有找到合适的访问类型，通常最好的解决办法就是增加一个合适的索引，这也是为什么索引对查询优化这么重要的原因了，因为索引能让MySQL以最高效，扫描行数最少的方式找到需要的记录。</p>
<p>需要注意的是，索引只是尽可能的只扫描所需要的数据行，并不是说增加索引就能让扫描的行数等于返回的行数。例如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设actor_id上建索引</span></span><br><span class="line"><span class="keyword">select</span> actor_id,<span class="keyword">count</span>(*) <span class="keyword">from</span> movie <span class="keyword">group</span> <span class="keyword">by</span> actor_id; <span class="comment">-- 使用了聚合函数，返回的行数大多数情况下远远小于扫描的行数</span></span><br></pre></td></tr></table></figure>

<p>如果发现查询需要扫描大量的数据但只返回少数的几行，那么通常可以尝试下面的技巧去优化：</p>
<ol>
<li>使用索引覆盖扫描，把所有需要用的列都放在索引中，这样存储引擎无需回表获取对应行就可以返回结果了。</li>
<li>改变库表结构，例如使用单独的汇总表（例如上述聚合函数的情况优化）</li>
<li>重写复杂查询，让MySQL优化器能够以更优化的方式执行查询</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/17/Java并发编程（二）之线程的创建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/17/Java并发编程（二）之线程的创建/" itemprop="url">Java并发编程（二）之线程的创建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-17T16:01:37+08:00">
                2019-11-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇讲了什么是并发，什么是多线程，这次我们讲一讲如何创建一个线程.</p>
<ol>
<li>继承Thread类，并重写其run方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承Thread类并重写其run方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am a Thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>上述方式直接继承了Thread类，并重写了run方法， 在main方法中创建了一个线程实例，并调用其start方法启动了线程。需要注意的是，当创建完线程实例之后，线程并没有启动，直到调用了run方法后才真正的启动了线程。</p>
<p>其实调用了start方法后，线程也没有马上执行，而是处于了就绪状态（线程有多种状态，例如就绪，挂起，运行等，以后再详细说），就绪状态就是指线程已经获取了除了CPU资源外其他所有的所需资源，，一旦获取到CPU使用权限，就会真正处于运行状态，也就是运行run方法中的代码，直到run方法执行完毕，进程就变为终止状态。</p>
<p>使用继承Thread类这种方式的好处是，在run方法中获取当前线程，直接使用this关键字就可以了，不用使用<code>Thread.currentThread()</code>方法；缺点是Java是不支持多继承的，继承了Thread就不能继承别的类，另外就是线程任务没有与代码分离，多个线程执行同样的任务时，需要重复多分任务代码。</p>
<ol start="2">
<li>实现Runable接口并重写run方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//实例化任务类</span></span><br><span class="line">        MyRunable myRunable = <span class="keyword">new</span> MyRunable();</span><br><span class="line">        <span class="comment">//将任务实例作为参数创建线程并启动</span></span><br><span class="line">        <span class="keyword">new</span> Thread(myRunable).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myRunable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现Runable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am a Thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>上述方式，实现Runable接口，避免了占用继承的位置，同时，任务与代码分离，两个线程共用同一个task代码逻辑。但是无论是继承Thread类还是实现Runable接口来创建线程（这两种方式也是我们大学时候Java程序设计课上，老师提到的两种方法），都有一个缺点，那就是任务没有返回值，大家也可以看到run方法函数签名中的返回类型是<code>void</code>。下面看最后一种有返回值的方式-使用<code>FutureTask</code></p>
<ol start="3">
<li>使用FutureTask<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建异步任务</span></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCallable());</span><br><span class="line">        <span class="comment">//将任务作为参数新建线程并启动</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取执行结果</span></span><br><span class="line">            String result = futureTask.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建任务类，类似于Runable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am a Thread"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>如上，代码中MyCallable类实现了Callable接口的call方法，在main中创建一个FutureTask对象，构造函数为Callable的实例，然后使用创建的FutureTask实例作为任务创建了一个线程并且启动，最后通过<code>futureTask.get()</code>等待任务执行完毕获取任务的返回结果。</p>
<p>除了这三种方法，其实还有一种高级用法，那就是使用线程池，这里就暂时先不详细的说了，简单说一说线程池主要解决的问题吧：</p>
<pre><code>1. 当执行大量异步任务时，每当需要执行异步任务就要new一个线程来运行，而线程的创建和销毁都是需要开销的。线程池中的线程可以复用，不需要每次执行任务都创建销毁。
2. 线程池提供了一些对资源限制和管理的手段，比如限制线程个数，动态新增线程等，线程池也保留了一些基本的数据统计，比如当前线程完成的任务数目等。</code></pre><p>线程池的使用，以及其原理，篇幅比较长，这篇文章就暂时不讲了，我们后续再讲，这篇就先到这吧。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/13/Java并发编程（一）之并发编程基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/13/Java并发编程（一）之并发编程基础知识/" itemprop="url">Java并发编程（一）之并发编程基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-13T21:02:52+08:00">
                2019-11-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>并发编程是每一个软件工程师（不要再叫自己程序员了，我们是软件工程师）都需要学习的知识，对于一个优秀的软件工程师来说，掌握好并发编程是一门必修课。所以，为了成为一名优秀的软件工程师，我在半年多以前就开始学习并发编程的知识，但是因为后来工作的原因，这个学习计划就被搁置了，今天再次回顾以前学习的知识，发现大部分都被我忘记了，因为工作中用到并发编程的知识实在是少。做Java后端开发的同学也应该深有体会，大部分工作只是业务逻辑的curd，一些同行也戏称自己是“curd boy”。今天再次拾起并发编程的知识，也在此做个笔记，分享一下，有理解的不正确的还请大家指正，共同学习，也为自己加深一遍印象，让自己忘得慢一些，也方便以后复习的时候再去慢慢翻书，直接看笔记就好，会省下很多时间。</p>
<p>要学习并发编程，首先我们要了解，什么是并发编程？</p>
<p>提起并发编程很多人会混乱并发与并行两个概念，所以首先要澄清并发与并行的概念与区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并发是指同一个时间段内多个任务同时都在执行，而并行是说在单位时间内多个任务同时执行。</span><br></pre></td></tr></table></figure>

<p>看起来很迷惑对不对，什么叫同一个时间段，什么叫单位时间？通俗的来说，一个时间段有多个单位时间累积而成，并发就是多个任务在这个时间段内执行，但不一定在同一个单位时间执行。而并行则是多个任务在同一个单位时间同时执行。</p>
<p>举个例子：</p>
<p>就拿人吃饭来说，一般大家吃饭的时候都会有再配一碗汤，我们可以把吃饭看做两个任务，一个是吃馒头，一个是喝汤，吃一口馒头是一个单位时间，喝一口汤也是一个单位时间，吃饭花费的时间就是一个时间段，而我们的嘴，是用来执行吃饭任务的，也就是一个CPU。一般我们吃饭的时候都是吃两口馒头，喝一口汤，在单个CPU的情况下（也就是我们只有一个嘴的情况下），吃馒头和喝汤是交替执行的，不可能在吃馒头的同时再喝一口汤，这就是并发，两个任务吃馒头喝汤，在同一个时间段内执行，但不一定是同一个单位时间执行。那么什么是并行呢，假设有人长了两张嘴，在吃饭的时候，一张嘴吃馒头的同时，另一张嘴喝汤，在同一个单位时间，执行两个或者多个任务，这就是并行。</p>
<p>在单CPU时代，多个任务是共享一个CPU的，当一个任务占用CPU时，其他任务就会被挂起不能执行，当占用CPU的任务时间片用完后，才会把CPU让给其他任务使用，也就是，当我们吃馒头的时候，嘴正在被占用着，喝汤这个任务就没法占用我们的嘴，只有当咬下这一口馒头，才会把嘴的使用权交给喝汤这个任务。</p>
<p>在单CPU时代，多线程编程是没有太大意义的，因为CPU只有一个，每个线程都只能交替使用这一个CPU，这样会导致线程间频繁的上下文切换，这也会带来额外的开销。就好比我们吃饭的时候，咬一口馒头咽下去，再伸手拿汤递到嘴边喝一口，再咬一口馒头咽下去，再把汤递到嘴边喝一口，这样的方式显然没有我们一开始就只吃馒头，吃完馒头，再端起汤来一口一口喝掉来的省时间。</p>
<p>如果为双CPU配置，线程A和线程B各自在自己的cpu上执行任务，那就真正的实现了并行运行。但在多线程编程实践中，线程的个数往往多余CPU的个数，所以一般都称多线程并发编程而不多线程并行编程。</p>
<p>到如今，连个人电脑都不止单个CPU了，一般的服务器的CPU个数几乎都能达到几十个，这打破了单个CPU对多线程编程效能的限制，多个CPU意味着每个线程都可以使用自己的CPU运行，这减少了线程上下文切换的开销，但随着对应用系统性能和吞吐量要求的提高，出现了处理海量数据和请求的要求，这些都对高并发编程有着迫切的需求。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/08/Redis中的数据结构之简单动态字符串（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/08/Redis中的数据结构之简单动态字符串（二）/" itemprop="url">Redis中的数据结构之简单动态字符串（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-08T20:10:42+08:00">
                2019-11-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇我们讲到了Redis中简单动态字符串与c语言中字符串相比的一个优势，也就是获取字符串长度时的时间复杂度有了大幅度降低，满足了Redis在效率方面的要求。</p>
<p>今天来说一下，SDS是如何满足Redis对字符串在安全性方面的要求。</p>
<p>除了获取字符串长度的复杂度高之外，C语言中字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow），例如<code>&lt;string.h&gt;/strcat</code>函数可以将<code>src</code>字符串中的内容拼接到<code>dest</code>字符串末尾。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcat</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span></span><br></pre></td></tr></table></figure>

<p>举个例子，假如一段程序，在内存中有两个紧紧相邻的c语言字符串<code>s1</code>和<code>s2</code>与<code>Redis</code>,<code>MongoDB</code>，如图所示</p>
<p><img src="/pic_doc/c_string_s1&s2.jpeg" alt="在内存中紧邻的两个C字符串"> </p>
<p>如果一个程序员决定通过使用<code>strcat</code>函数来修改<code>s1</code>的内容为<code>Redis Cluster</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(s1, <span class="string">"Cluster"</span>);</span><br></pre></td></tr></table></figure>

<p>但他忘了在执行<code>strcat</code>之前为<code>s1</code>分配足够的空间（众所周知，在c语言与c++中需要程序员自己手工对内存进行管理），那么就会导致<code>Cluster</code>溢出到<code>s2</code>的位置，如下图：</p>
<p><img src="/pic_doc/c_string_s1&s2_buf_overflow.jpeg" alt="s2被溢出的内容覆盖"> </p>
<p>而在SDS中，通过一个巧妙的方法避免了这种情况的发生，也就是利用SDS结构体中的<code>free</code>属性(在最新版的Redis中，SDS的结构体中已经移除了free属性，转而使用alloc来代替，不过两个属性的含义有所不同，但在SDS中起到的作用基本一致，这个有机会再说哈)。那么SDS是怎么使用<code>free</code>属性来杜绝缓冲区溢出的呢？</p>
<p>举个例子：SDS的API中也有一个用于执行拼接操作的<code>sdscat</code>函数，类似于c语言中的<code>strcat</code>，当SDS中<code>sdscat</code>需要拼接字符串的时候，会先检查SDS的空间是否满足所需的要求，如果不满足的话，Redis会自动将SDS的空间扩展到所需大小，然后再执行拼接操作，所以使用SDS既不必像c语言中手动修改空间大小，也不会出现前面所说的c语言中字符串的缓冲区问题。（<code>注：这里只是举了一个拼接字符串的例子，其他的有关SDS的API在修改SDS的时候也会做上面的操作</code>）</p>
<p>例如有以下SDS：</p>
<p><img src="/pic_doc/redis_sds.jpeg" alt="执行sdscat之前"></p>
<p>我们执行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdscat(s,<span class="string">"Cluster"</span>);</span><br></pre></td></tr></table></figure>

<p>拼接完的SDS如下图所示：</p>
<p><img src="/pic_doc/sds_after_sdscat.jpeg" alt="执行sdscat之后"></p>
<p>注意：上图所示的SDS，sdscat不仅对SDS进行了拼接操作，还为SDS分配了13字节的未使用空间，并且拼接之后的字符串正好也是13字节长，这种现象既不是巧合，也不是bug(工业界以及大规模使用的Redis怎么会有bug！？)，这和SDS的空间分配策略有关系，空间分配策略又是Redis一个很巧妙的设计，所以，我们下一篇再讲吧！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/23/Redis中的数据结构之简单动态字符串/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/23/Redis中的数据结构之简单动态字符串/" itemprop="url">Redis中的数据结构之简单动态字符串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-23T20:57:21+08:00">
                2019-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前段时间学习Redis，在网上一搜Redis教程，绝大部分的教程都是在教你怎么使用Redis，比如如何set/get一个字符串，Redis列表怎么添加（获取）值等基础用法，这些就相当于我们学习一门计算机语言的语法过程。简单浏览一遍就好了，用到的时候不记得了再去查。（当然你如果记忆力强悍，全部记住也是极好的，省去了查百度的时间，提高了效率）。这些基础的语法知识，个人感觉没有什么含金量，熟悉编程的人几乎大部分人一看就懂。</p>
<p>所以，我们要学习里面涉及到的原理知识，素闻Redis中的数据结构异常牛B，我呢就找了一本书《Redis设计与实现》来学习，在此也记录一下，加深一下印象，也分享一下学习笔记。</p>
<p>首先我们来学习Redis中最简单的数据结构 <code>SDS</code>，也就是 <code>simple dynamic string</code>，翻译过来就是 <code>简单动态字符串</code>。正如其名字所说的，这种数据结构是一个简单的，动态的(可以被修改值)的字符串。</p>
<p>当Redis需要的不仅仅是一个字符串字面量，而是需要一个可以被修改的字符串的时候，Redis就会使用SDS来表示字符串的值。比如在Redis中，包含字符串值的键值对在底层都是由SDS实现的。</p>
<p>举个例子，在Redis客户端执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span> set msg "hello word"</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>这个命令大家都很熟悉，这在Redis中创建了一个新的键值对，键为<code>msg</code>，值就是我们最熟悉的<code>hello world</code>。其中，<code>msg</code>是一个字符串，<code>hello world</code>也是一个字符串。上面说了，包含字符串值的键值对在底层都是由SDS实现的。<br>所以</p>
<ul>
<li>键值对的键 <code>msg</code>是一个字符串对象，底层的实现是一个保存着字符串<code>msg</code>的SDS</li>
<li>键值对的值 <code>hello world</code>也是一个字符串对象，底层的实现是一个保存着字符串<code>hello world</code>的SDS</li>
</ul>
<p>再举个例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span> rpush fruits "apple" "banana" "cherry"</span><br></pre></td></tr></table></figure>

<p>这个命令大家也知道，在Redis中创建了一个列表，其实也是一个键值对，键为<code>fruits</code>，值为<code>&quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</code>，其中：</p>
<ul>
<li>键值对的键 <code>fruits</code>是一个字符串对象，底层的实现是一个保存着字符串<code>fruits</code>的SDS</li>
<li>键值对的值 <code>&quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</code>是一个列表对象，其中包含了三个字符串对象，这三个字符串对象分别由三个SDS实现：第一个SDS保存着”apple”，第二个SDS保存着”banana”，第三个SDS保存着”cherry”</li>
</ul>
<p>除了用来保存Redis中的字符串值之外，SDS还被用作缓冲区，这个以后我们再说。</p>
<p>说了一些SDS在Redis中的应用，那么，SDS的数据结构到底是什么样子呢？</p>
<p>我们来看一下SDS的数据结构定义代码：</p>
<ul>
<li>注：此书基于的Redis版本不是最新的，最新的版本中，SDS的数据结构做了一些优化，但是大同小异，大家有兴趣可以去github看Redis最新的源码。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">//记录buf数组中已使用的字节数量，等于SDS所保存的字符串长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">//记录buf数组中未使用的字节数量</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">//字节数组，用来保存字符串的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>比如我们定义一个字符串“Redis”，在SDS中会怎么存储呢？<br><img src="/pic_doc/redis_sds.jpeg" alt> </p>
<ol>
<li>free属性的值为0，表示这个SDS没有分配任何未使用空间。</li>
<li>len属性值为5，表示这个SDS保存了一个长度为5的字符串</li>
<li>buf属性是一个char类型的数组，数组的前五个元素分别保存了 ‘R’,’e’,’d’,’i’,’s’ 五个字符，而最后一个元素则保存了空字符’\0’。</li>
</ol>
<p>学过c语言的都知道，c语言中字符串的结尾惯例就是一个空字符 <code>\0</code>，Redis是用c语言编写的，所以遵循c语言字符串结尾的规范。大家可以看到结尾的空字符<code>\0</code>虽然占用了一个字符的空间，但不计算在SDS的len属性里面，所以这个空字符串对于SDS的使用者是完全透明的，这样的好处是SDS可以直接重用一部分c语言字符串库中的函数。比如 <code>&lt;stdio.h&gt;/printf</code>函数。</p>
<p>说完SDS的数据结构，大家肯定知道了SDS中的<code>len</code>与<code>buf[]</code>属性的含义，但可能不知道<code>free</code>是用来做什么的，我们暂时不讨论这个，下一篇再详细说明。</p>
<p>既然Redis是用c语言编写的，那么保存字符串的时候为什么不用c语言中的表示方式呢？为何还要定义一个SDS呢？</p>
<p>我们先来看一下”Redis”这个字符串在c语言中的表示<br><img src="/pic_doc/redis_c_string.jpeg" alt></p>
<p>可以看到，c语言使用的这种简单的字符串表示方式，没有记录字符串自身的长度信息，也就是没有SDS中的<code>len</code>属性。想一下若是在c语言中获取这个字符串的长度该怎么获取呢？</p>
<p>只有一种方法，那就是循环遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符<code>\0</code>为止。这个操作的时间复杂度为<code>O(n)</code>，虽然这个复杂度看起来并不是很高，但是还是满足不了Redis在效率性方面的要求（众所周知，Redis的应用场景大部分都会面临海量的并发，对其性能要求很高）。</p>
<p>那么SDS在获取字符串长度时候的时间复杂度是多少呢？因为SDS在len属性中记录了SDS本身字符串的长度，所以获取字符串长度只需要访问SDS的len属性，所以时间复杂度为<code>O(1)</code>。</p>
<p>可以看到，通过使用SDS而非c语言中的字符串，Redis将获取字符串的时间复杂度从<code>O(n)</code>降到了<code>O(1)</code>，所以这确保了获取字符串长度的工作不会成为Redis的性能瓶颈。</p>
<p>当然，SDS与c字符串相比并不只是满足Redis在效率方面的要求，也满足了Redis对安全性以及功能方面的要求，这个我们下期再说吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/20/LeetCode-有序数组中的单一元素/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/20/LeetCode-有序数组中的单一元素/" itemprop="url">LeetCode-有序数组中的单一元素</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-20T19:46:34+08:00">
                2019-10-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天来讲一道三月份面试时候遇到的算法题，三月份遇到的，最近刷题又遇到，刚好也开始慢慢地写博客了，就记录下来吧。</p>
<blockquote>
<p>题目描述<br>给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</p>
</blockquote>
<ul>
<li><p>示例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,2,3,3,4,4,8,8]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,3,7,7,10,11,11]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。</p>
</li>
</ul>
<p>下面来看看如何解决</p>
<p>首先，我们看到，题目中说的是<code>有序数组</code>，其次，时间复杂度要求<code>O(log n)</code>，最后，查找出这个数，是一个查找问题。根据这些条件，我们想一想，适用于有序数组，时间复杂度为O(log n)的查找算法是哪一个？就是我们之前讲过的<code>二分查找</code>。</p>
<p>那么如何利用二分查找解决这个问题呢？难点是，二分搜索后怎么判断是左半边还是右半边。解决方式是通过mid的奇偶性。</p>
<ol>
<li><p>令 key 为 Single Element 在数组中的位置。如果 m 为偶数，并且 m + 1 &lt; key，那么 nums[m] == nums[m + 1]；m + 1 &gt;= key，那么 nums[m] != nums[m + 1]；</p>
</li>
<li><p>从上面的规律可以知道，如果 nums[m] == nums[m + 1]，那么 key 所在的数组位置为 [m + 2, h]，此时令 l = m + 2；如果 nums[m] != nums[m + 1]，那么 key 所在的数组位置为 [l, m]，此时令 h = m；</p>
</li>
<li><p>因为 h 的赋值表达式为 h = m，那么循环条件也就只能使用 l &lt; h 这种形式；</p>
</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (m % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            m--;   <span class="comment">// 保证 l/h/m 都在偶数位，使得查找区间大小一直都是奇数</span></span><br><span class="line">        <span class="keyword">if</span> (nums[m] == nums[m + <span class="number">1</span>])</span><br><span class="line">            l = m + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            h = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个题还有一个变种，当我们不考虑时间复杂度以及有序数组的条件时，如何快速找出数组中的单一元素呢？</p>
<ul>
<li>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,2,3,4,4,3,8,8]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>先看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        res = res^num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如代码所示，我们又用到了以前讲过的神奇的位运算，这次用到的位运算是<code>异或</code>，运算符是<code>^</code>。</p>
<p>异或运算有什么特点呢？<br>0^0=0，1^0=1，0^1=1，1^1=0,也就是同为0，异为1。0异或任何数字，都会的到这个数字本身。</p>
<p>于是上面代码运行的过程大家可以自己用异或算一下，原理就是，数组中成对的数字经过异或运算之后的结果，也就是变量<code>res</code>变为了0，然后0再与数组中的单一元素进行异或运算，变量<code>res</code>就变为了这个单一元素，于是我们就得到了数组中的单一元素。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/09/求一个整数转换为二进制之后其中1的个数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/09/求一个整数转换为二进制之后其中1的个数/" itemprop="url">求一个整数转换为二进制之后其中1的个数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-09T19:20:01+08:00">
                2019-10-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天面试摩拜单车遇到一道算法题，题目如下：</p>
<p>给定一个正整数范围(m,n)，返回一个数组，该数组是每个正整数转换为相应二进制之后包含1的个数</p>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 (1,5) ， </span><br><span class="line">1的二进制位1，二进制表示中包含位1的个数位1，</span><br><span class="line">2的二进制位10，二进制表示中包含位1的个数位1，</span><br><span class="line">3的二进制为11，二进制表示中包含位1的个数位2，</span><br><span class="line">4的二进制位100，二进制表示中包含位1的个数位1，</span><br><span class="line">5的二进制位101，二进制表示中包含位1的个数位2，</span><br><span class="line">所以返回数组 [1，1，2，1，2]</span><br></pre></td></tr></table></figure>

<p>这道题有点像LeetCode上<code>位1的个数</code>这道题目。</p>
<p>那么怎么解决呢？</p>
<p>最简单的方法就是，求出每一个数二进制中位1的个数，拼成一个数组，那么如何求出正整数中二进制位1的个数呢？</p>
<p>重点就是求每个数的位1的个数。</p>
<p>这里就要用到位运算了。大家初中高中或者大学学计算机基础的时候应该都学过基础位运算，也就是<code>与</code>，<code>或</code>，<code>非</code>的运算。(还有一些比较复杂的，例如<code>异或</code>，<code>与非</code>等组合位运算)</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NumberOfOne</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不断把数字最后一个 <code>1</code> 反转，并把答案加一。当数字变成 <code>0</code> 的时候偶，我们就知道它没有 <code>1</code> 的位了，此时返回答案。</p>
<p>这里关键的想法是对于任意数字 <code>n</code> ，将 <code>n</code> 和 <code>n-1</code>做与运算，会把最后一个 <code>1</code> 的位变成 <code>0</code> 。为什么？考虑 <code>n</code> 和 <code>n−1</code> 的二进制表示。</p>
<p>我们来详细解读一下 <code>n &amp; (n - 1)</code></p>
<ol>
<li>假设<code>n=5</code>,<code>n &amp; (n - 1)</code>就是<code>5&amp;4</code>，转换为二进制就是 <code>101&amp;100=100</code></li>
<li>假设<code>n=4</code>,<code>n &amp; (n - 1)</code>就是<code>4&amp;3</code>，转换为二进制就是 <code>100&amp;011=000</code></li>
</ol>
<p>可以看到，每一次<code>n&amp;(n-1)</code>的操作就会把n中的位1减少一位，为什么呢？因为二进制，无论数字是多少，在二进制运算中，只要做了-1的操作，就会改变最后一位的值，1变为0或者0变为1.</p>
<p>1变为0就是上面<code>1</code>的情况，<br>0变为1就是上面<code>2</code>的情况。</p>
<p>可以发现，由于每次<code>- 1</code>操作都会带了位的变化，所以每次<code>n&amp;n-1</code>,都会把二进制中<code>最后的一位1</code>消除掉，比如<code>101&amp;100=100</code>，消除了<code>101</code>最后的1变为<code>100</code>，<code>100&amp;011=000</code>，消除了<code>100</code>最后的<code>1</code>，也是惟一的1变为<code>000</code>。所以，当我们不断把<code>n&amp;=n-1</code>，直到<code>n=0</code>的时候，n中的位1就被完全消除了，这个操作做了几次，也就代表n转换为二进制，其中位1的个数有几个。</p>
<p>看到这里，这道题最重要的问题就解决了，剩下的工作就是写个for循环将每位数的结果封装成一个数组就行了，for循环很简单，这里就不再赘述了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/01/LeetCode第一题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="猫屎咖啡">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫屎咖啡">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/01/LeetCode第一题/" itemprop="url">LeetCode第一题-TwoSum</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-01T20:14:26+08:00">
                2019-10-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>刷了无数遍的LeetCode第一题，为啥刷了无数遍呢，因为每次想提高自己算法与数据结构能力的时候我都会下定决心来LeetCode刷题，而每次刷题，都是从第一题开始…</p>
<p>不多扯淡，直接开题。</p>
<p>题目要求是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given an array of integers, return indices of the two numbers such that they add up to a specific target.</span><br><span class="line"></span><br><span class="line">You may assume that each input would have exactly one solution, and you may not use the same element twice.</span><br></pre></td></tr></table></figure>

<p>啥意思呢，帮英文不好的同学翻译一下：</p>
<p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>

<p>首先，一般人第一个想到的方法就是暴力破解，也就是直接循环两次数组，遍历数组中每个元素 <code>x</code>，再次遍历数组，并查找是否存在一个值与 <code>target - x</code> 相等的目标元素。</p>
<p>先亮出代码，我们再来讨论程序性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == target - nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, j &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们来讨论一下此种解决方式的代码性能，分析一段代码的性能，主要从时间复杂度，以及空间复杂度两个方面来考虑。<br>简单解释一下什么是时间复杂度，什么是空间复杂度。</p>
<p>时间复杂度指的是解决一个问题，程序所需要进行多少次操作。<br>空间复杂度指的是解决一个问题，所需要的额外空间。</p>
<p>上述算法的复杂度为：</p>
<p>时间复杂度：O(n<sup>2</sup>)，对于每个元素（一共<code>n</code>个），我们试图通过遍历数组的其余部分（其余的<code>n-1</code>个元素）来寻找它所对应的目标元素，这将耗费<code>O(n)</code>的时间。遍历数组中每个元素时间复杂度为O(n)，遍历数组其余部分的时间复杂度为<code>O(n)</code>（准确的来说为<code>O(n-1)</code>，但是因为<code>1</code>是常数，与n比起来可以忽略不计，所以简写为<code>O(n)</code>），因此时间复杂度为O(n<sup>2</sup>)。</p>
<p>空间复杂度：<code>O(1)</code>。</p>
<p>可以看到，此种方法的时间复杂度很高，因为这道题的本质还是在数组中查找元素，这相当于两层嵌套循环。说到查找元素，可能同学们会想到，可以用二分查找啊，二分查找不比简单的for循环速度快多了。确实，二分查找比暴力查找速度快得多，但是，二分查找只适用于有序数组，此题目中数组并不是有序的，所以不能使用二分查找。</p>
<p>那么，这道题有没有更加快速的解法呢？当然是有的。</p>
<p>上面说了，这道题的本质还是在数组中查找元素，重点在于查找，我们的目的是缩短查找的时间。那么有什么方法可以缩短查找时间呢？学过数据结构的同学应该都知道或者听说过一种数据结构–<code>散列表</code>（又叫做<code>哈希表</code>）。这种数据结构，在无冲突的情况下，查找元素的时间复杂度为<code>O(1)</code>，比暴力循环数组的<code>O(n)</code>快了很多。那么我们如何利用它来解决这个问题呢？</p>
<p>一个简单的实现，使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素<code>(target - nums[i])</code>是否存在于表中。注意，该目标元素不能是 <code>nums[i]</code> 本身！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, map.get(complement) &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>注：这里使用了Java中的集合类HashMap，其实HashMap本质上就是哈希表</code></p>
<p>复杂度分析：</p>
<p>时间复杂度：<code>O(n)</code>，<br>我们把包含有 <code>n</code> 个元素的列表遍历两次。由于哈希表将查找时间缩短到 <code>O(1)</code> ，所以时间复杂度为 <code>O(n)</code>。</p>
<p>空间复杂度：<code>O(n)</code>，<br>所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 <code>n</code> 个元素。</p>
<p>可以看到，我们将程序的时间复杂度从O(n<sup>2</sup>)降到了<code>O(n)</code>，这说明我们的程序变得更快了，但是空间复杂度从<code>O(1)</code>变成了<code>O(n)</code>，占用的空间更多了。我们使用空间换取了时间，在现在程序效率要求较高，而内存空间或者硬盘空间成本日益廉价的情况下，如果没有特殊要求，我们可以不关注程序的空间复杂度，只关心程序的时间复杂度。</p>
<p>上面哈希表的解法，我们使用了两遍哈希表，第一遍是把数组中的元素放到哈希表中，也就是建表；第二遍从哈希表中进行查找。<br>那么我们能不能使用一次哈希表就解决问题呢？</p>
<p>我们看一下下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(complement), i &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p>
<p>复杂度分析：</p>
<p>时间复杂度：<code>O(n)</code>，<br>我们只遍历了包含有 <code>n</code> 个元素的列表一次。在表中进行的每次查找只花费 <code>O(1)</code> 的时间。</p>
<p>空间复杂度：<code>O(n)</code>，<br>所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 <code>n</code> 个元素。</p>
<p>可以看到，这种方法的时间复杂度与空间复杂度，和两遍哈希表的方法是一样的，程序性能没有什么差别。但这种方法只用了一次for循环，看起来就很高端，看起来就要比两遍哈希表的方法效率要高（只是看起来要高，其实效率提高很有限。。），为啥还要讲最后一种解法呢？因为很多面试官就喜欢这种看起来高端的解法。（当然，只要你不用第一中方法暴力求解，面试官还是会欣赏你的。。。）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">猫屎咖啡</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/SheldonKubor" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:mjh123877@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">猫屎咖啡</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
