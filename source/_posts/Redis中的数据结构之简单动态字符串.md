---
title: Redis中的数据结构之简单动态字符串
date: 2019-10-23 20:57:21
tags: [Redis,数据结构]
---

前段时间学习Redis，在网上一搜Redis教程，绝大部分的教程都是在教你怎么使用Redis，比如如何set/get一个字符串，Redis列表怎么添加（获取）值等基础用法，这些就相当于我们学习一门计算机语言的语法过程。简单浏览一遍就好了，用到的时候不记得了再去查。（当然你如果记忆力强悍，全部记住也是极好的，省去了查百度的时间，提高了效率）。这些基础的语法知识，个人感觉没有什么含金量，熟悉编程的人几乎大部分人一看就懂。

所以，我们要学习里面涉及到的原理知识，素闻Redis中的数据结构异常牛B，我呢就找了一本书《Redis设计与实现》来学习，在此也记录一下，加深一下印象，也分享一下学习笔记。

首先我们来学习Redis中最简单的数据结构 `SDS`，也就是 `simple dynamic string`，翻译过来就是 `简单动态字符串`。正如其名字所说的，这种数据结构是一个简单的，动态的(可以被修改值)的字符串。

当Redis需要的不仅仅是一个字符串字面量，而是需要一个可以被修改的字符串的时候，Redis就会使用SDS来表示字符串的值。比如在Redis中，包含字符串值的键值对在底层都是由SDS实现的。

举个例子，在Redis客户端执行如下命令：
```shell
redis> set msg "hello word"
OK
```
这个命令大家都很熟悉，这在Redis中创建了一个新的键值对，键为`msg`，值就是我们最熟悉的`hello world`。其中，`msg`是一个字符串，`hello world`也是一个字符串。上面说了，包含字符串值的键值对在底层都是由SDS实现的。
所以
- 键值对的键 `msg`是一个字符串对象，底层的实现是一个保存着字符串`msg`的SDS
- 键值对的值 `hello world`也是一个字符串对象，底层的实现是一个保存着字符串`hello world`的SDS

再举个例子：
```shell
redis> rpush fruits "apple" "banana" "cherry"
```
这个命令大家也知道，在Redis中创建了一个列表，其实也是一个键值对，键为`fruits`，值为`"apple" "banana" "cherry"`，其中：
- 键值对的键 `fruits`是一个字符串对象，底层的实现是一个保存着字符串`fruits`的SDS
- 键值对的值 `"apple" "banana" "cherry"`是一个列表对象，其中包含了三个字符串对象，这三个字符串对象分别由三个SDS实现：第一个SDS保存着"apple"，第二个SDS保存着"banana"，第三个SDS保存着"cherry"

除了用来保存Redis中的字符串值之外，SDS还被用作缓冲区，这个以后我们再说。

说了一些SDS在Redis中的应用，那么，SDS的数据结构到底是什么样子呢？

我们来看一下SDS的数据结构定义代码：
- 注：此书基于的Redis版本不是最新的，最新的版本中，SDS的数据结构做了一些优化，但是大同小异，大家有兴趣可以去github看Redis最新的源码。
```c++
struct sdshdr {
    int len; //记录buf数组中已使用的字节数量，等于SDS所保存的字符串长度
    int free; //记录buf数组中未使用的字节数量
    char buf[]; //字节数组，用来保存字符串的值
}
```

比如我们定义一个字符串“Redis”，在SDS中会怎么存储呢？
![](https://github.com/SheldonKubor/hexo/blob/master/source/_posts/pic_doc/redis_sds.jpeg) 


1. free属性的值为0，表示这个SDS没有分配任何未使用空间。
2. len属性值为5，表示这个SDS保存了一个长度为5的字符串
3. buf属性是一个char类型的数组，数组的前五个元素分别保存了 'R','e','d','i','s' 五个字符，而最后一个元素则保存了空字符'\0'。

学过c语言的都知道，c语言中字符串的结尾惯例就是一个空字符 `\0`，Redis是用c语言编写的，所以遵循c语言字符串结尾的规范。大家可以看到结尾的空字符`\0`虽然占用了一个字符的空间，但不计算在SDS的len属性里面，所以这个空字符串对于SDS的使用者是完全透明的，这样的好处是SDS可以直接重用一部分c语言字符串库中的函数。比如 `<stdio.h>/printf`函数。

说完SDS的数据结构，大家肯定知道了SDS中的`len`与`buf[]`属性的含义，但可能不知道`free`是用来做什么的，我们暂时不讨论这个，下一篇再详细说明。

既然Redis是用c语言编写的，那么保存字符串的时候为什么不用c语言中的表示方式呢？为何还要定义一个SDS呢？

我们先来看一下"Redis"这个字符串在c语言中的表示
![](https://github.com/SheldonKubor/hexo/blob/master/source/_posts/pic_doc/redis_c_string.jpeg)

可以看到，c语言使用的这种简单的字符串表示方式，没有记录字符串自身的长度信息，也就是没有SDS中的`len`属性。想一下若是在c语言中获取这个字符串的长度该怎么获取呢？

只有一种方法，那就是循环遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符`\0`为止。这个操作的时间复杂度为`O(n)`，虽然这个复杂度看起来并不是很高，但是还是满足不了Redis在效率性方面的要求（众所周知，Redis的应用场景大部分都会面临海量的并发，对其性能要求很高）。

那么SDS在获取字符串长度时候的时间复杂度是多少呢？因为SDS在len属性中记录了SDS本身字符串的长度，所以获取字符串长度只需要访问SDS的len属性，所以时间复杂度为`O(1)`。

可以看到，通过使用SDS而非c语言中的字符串，Redis将获取字符串的时间复杂度从`O(n)`降到了`O(1)`，所以这确保了获取字符串长度的工作不会成为Redis的性能瓶颈。

当然，SDS与c字符串相比并不只是满足Redis在效率方面的要求，也满足了Redis对安全性以及功能方面的要求，这个我们下期再说吧。


