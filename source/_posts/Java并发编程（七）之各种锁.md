---
title: Java并发编程（七）之各种锁
date: 2020-04-20 15:31:36
tags: [多线程,并发,Java]
---
我们已经知道了在线程同步问题上，我们可以通过使用`synchronized`加锁来保证线程安全。简单介绍一下各种锁的概念以及含义。

### 1. 乐观锁与悲观锁

乐观锁和悲观锁是在数据库中引入的名词，但是在并发包锁里面也引入了类似的思想（计算机科学中很多思想都是类似的），所以也简单了解一下。

- 乐观锁

乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。

通常实现是这样的：在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。也就是先查询出那条记录，获取出version字段,如果要对那条记录进行操作(更新),则先判断此刻version的值是否与刚刚查询出来时的version的值相等，如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将version字段的值加1；如果更新时发现此刻的version值与刚刚获取出来的version的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。

- 悲观锁

与乐观锁相对应的就是悲观锁了。悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了

悲观锁又分为共享锁与排它锁
    
    1. 共享锁
    共享锁指的就是对于多个不同的事务，对同一个资源共享同一个锁。相当于对于同一把门，它拥有多个钥匙一样，这个就是所谓的共享锁。
    刚刚说了，对于悲观锁，一般数据库已经实现了，共享锁也属于悲观锁的一种，那么共享锁在mysql中是通过什么命令来调用呢。通过查询资料，了解到通过在执行语句后面加上lock in share mode就代表对某些资源加上共享锁了。

    2. 排它锁
    排它锁与共享锁相对应，就是指对于多个不同的事务，对同一个资源只能有一把锁。与共享锁类似，在需要执行的语句后面加上for update就可以了

### 2. 公平锁与非公平锁
公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。而非公平锁不一定先到先得。

Java中`ReentrantLock`提供了公平和非公平锁的实现。

- 公平锁 : `ReentrantLock lock = new ReentrantLock(true)`
- 非公平锁 : `ReentrantLock lock = new ReentrantLock(false)`

`注：`如果构造函数不传递参数，则默认是非公平锁。

简单举个例子解释一下：

加入线程A已经持有了锁，这时候线程B请求该锁时将会被挂起。当线程A释放锁之后，假设有一个线程C也需要获取该锁，如果采用非公平锁的方式，根据线程调度策略，线程B与线程C两者之一可能获取到锁；而如果使用公平锁，则需要把C挂起，让B先获取当前锁（先到先得）。

需要注意的是，在没有公平性需求的前提下，尽量使用非公平锁，因为公平锁会带来性能开销（很容易理解，公平锁需要一些其他操作来实现先到先得的公平性）。

### 3. 独占锁（排它锁）与共享锁
与上面数据库中的锁定义类似。

- 独占锁
任何时候只有一个线程能得到锁，`ReentrantLock`就是以独占的方式实现的。由于每次访问共享资源都会先加上锁，限制了并发性。独占锁只允许在同一时间，由一个线程来进行读写操作，其他线程不能必须等待当前线程释放锁，才能进行读取操作。

- 共享锁
可以同时由多个线程持有，例如`ReadWriteLock`读写锁。它允许一个共享资源被多个线程同时进行`读`操作。

### 4. 可重入锁

当一个线程要获取被另一个线程持有的独占锁的时候，将会被阻塞，那么该线程获取它自己已经获取的锁会不会被阻塞呢？如果不被阻塞，我们就说该锁是可以虫儿不的。

我们来看一个例子

```java
public class Hello{
    public synchronized void helloA(){
        System.out.println("hello a");
    }
    public synchronized void helloB(){
        System.out.println("hello b");
        helloA();
    }
}
```
可以看到，两个方法`helloA`与`helloB`，都被`synchronized`修饰了，也就是都加了锁。我们知道对于普通同步方法，锁是当前实例对象，两个方法的锁是同一把锁，都是`this`。

在调用`helloB`方法的时候，会先获取到锁，然后打印输出`hello b`，然后再调用`helloA`方法，由于`helloA`方法也是加了锁的，所以需要再次获取一次该锁，若是该锁是不可重入的，那么调用线程将会被阻塞，`helloB`方法将会被阻塞。但是实际上，`synchronized`锁时可重入锁。其原理是，在锁内部维护一个标识，代表当前锁被哪个线程占用，然后会关联一个计数器（也就是上一篇中提到的monitor的进入数），一开始计数器为0，任何线程都可以获取该锁，当一个线程获取到锁之后（monitorenter指令），计数器的值加1，其他线程获取该锁的时候，会先判断锁的所有者是不是自己，若不是自己，该线程就会被阻塞。若是自己，就会把计数器的值加1，释放锁后计数器的值会减1（monitorexit指令），当计数器的值又变回0的时候，锁里面的线程标识会被重置为`null`，这时候被阻塞的线程，就会被唤醒来竞争获取该锁。

### 5. 自旋锁

Java中的线程是与操作系统中的线程一一对应的，当一个线程获取锁失败后，会切换到操作系统内核态挂起，当该线程获取到锁时，又需要将其切换到内核态唤醒。我们知道，操作系统从用户态切换到内核态是很耗性能的。而自旋锁在一定程度上避免了用户态与内核态之间的切换，自旋锁是当线程在获取锁的时候，如果该锁已被其他线程占有，当前线程不会马上切换到内核态阻塞自己，而是在不放弃CPU使用权的情况下，多次尝试获取该锁（默认次数是10，可以使用-XX：PreBlockSpinsh参数设置该值），在后面几次尝试中，其他线程可能已经释放了该锁。如果尝试指定次数后仍没有获取到锁，线程才会切换到内核态阻塞挂起自己。

由此看来，自旋锁换区线程阻塞调度的开销，是使用了CPU的时间，缺点就是，有可能这些CPU的时间被白白浪费了。
