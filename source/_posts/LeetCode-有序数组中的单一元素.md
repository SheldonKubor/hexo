---
title: LeetCode-有序数组中的单一元素
date: 2019-10-20 19:46:34
tags: [算法,LeetCode,面试题]
---

今天来讲一道三月份面试时候遇到的算法题，三月份遇到的，最近刷题又遇到，刚好也开始慢慢地写博客了，就记录下来吧。

> 题目描述
给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。

- 示例一：
```
输入: [1,1,2,3,3,4,4,8,8]
输出: 2
```

- 示例二：
```
输入: [3,3,7,7,10,11,11]
输出: 10
```
- 注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。

下面来看看如何解决

首先，我们看到，题目中说的是`有序数组`，其次，时间复杂度要求`O(log n)`，最后，查找出这个数，是一个查找问题。根据这些条件，我们想一想，适用于有序数组，时间复杂度为O(log n)的查找算法是哪一个？就是我们之前讲过的`二分查找`。

那么如何利用二分查找解决这个问题呢？难点是，二分搜索后怎么判断是左半边还是右半边。解决方式是通过mid的奇偶性。

1. 令 key 为 Single Element 在数组中的位置。如果 m 为偶数，并且 m + 1 < key，那么 nums[m] == nums[m + 1]；m + 1 >= key，那么 nums[m] != nums[m + 1]；

2. 从上面的规律可以知道，如果 nums[m] == nums[m + 1]，那么 key 所在的数组位置为 [m + 2, h]，此时令 l = m + 2；如果 nums[m] != nums[m + 1]，那么 key 所在的数组位置为 [l, m]，此时令 h = m；

3. 因为 h 的赋值表达式为 h = m，那么循环条件也就只能使用 l < h 这种形式；

代码如下：

```java
public int singleNonDuplicate(int[] nums) {
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (m % 2 == 1)
            m--;   // 保证 l/h/m 都在偶数位，使得查找区间大小一直都是奇数
        if (nums[m] == nums[m + 1])
            l = m + 2;
        else
            h = m;
    }
    return nums[l];
}
```

这个题还有一个变种，当我们不考虑时间复杂度以及有序数组的条件时，如何快速找出数组中的单一元素呢？
- 示例：
```
输入: [1,1,2,3,4,4,3,8,8]
输出: 2
```
先看代码：

```java
public static int singleNonDuplicate(int[] nums) {
    int res = 0;
    for(int num : nums){
        res = res^num;
    }
    return res;
}
```

如代码所示，我们又用到了以前讲过的神奇的位运算，这次用到的位运算是`异或`，运算符是`^`。

异或运算有什么特点呢？
0^0=0，1^0=1，0^1=1，1^1=0,也就是同为0，异为1。0异或任何数字，都会的到这个数字本身。

于是上面代码运行的过程大家可以自己用异或算一下，原理就是，数组中成对的数字经过异或运算之后的结果，也就是变量`res`变为了0，然后0再与数组中的单一元素进行异或运算，变量`res`就变为了这个单一元素，于是我们就得到了数组中的单一元素。


