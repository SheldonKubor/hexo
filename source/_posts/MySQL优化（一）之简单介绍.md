---
title: MySQL优化（一）之简单介绍
date: 2019-11-17 17:40:13
tags: [MySQL,SQL优化]
---

做后端开发的同学们免不了接触MySQL，虽然现在有很多ORM框架，但是个人认为，在一些情况下还是需要我们手工写SQL的，个人也比较喜欢手写SQL，可能是做过半年数据分析类工作的原因吧。而能够手写SQL查询出我们想要的数据只是一个合格后端开发工程师的基本素质，我们还得学习如何优化我们的SQL，虽然现在很多大公司都有DBA这个职位，但是我们做后端开发的多了解一些SQL优化的知识也是很有帮助的。

说到数据库优化，我们最常遇到的就是查询优化，而最常用的查询优化手段就是建立索引。还有就是在建库建表的时候就要做好的库表结构优化。

查询优化，索引优化，库表结构优化需要齐头并进，一个不落。这三者相辅相成，在获得编写sql查询优化的经验的同时，我们也会学习到如何为高效的查询设计表结构以及索引，同样的，也可以学习到优化库表结构时将会影响到那些类型的查询。

一条sql语句为什么需要优化？那绝对是因为它的查询速度慢，那么为什么查询速度会慢呢？

查询性能低下最基本的原因就是访问的数据太多。某些查询了能不可避免的需要筛选大量数据，但这种情况不常见。大部分性能低下的查询都可以通过减少访问数据量的方式进行优化。对于低效的查询，我们首先可以通过以下两个步骤来分析：

    1. 确认应用程序是够在检索大量超过我们实际需要的数据。这通常意味着我们访问了太多的行或者列。
    2. 确认MySQL服务层是够在分析大量超过需要的数据行。

知道了从哪方面入手，那么就会知道如何优化了

第一，访问太多行或者列的：

1. 若是访问太多行

例如，在某个新闻网站中取出100条记录，但只是在页面上显示前10条。对于这种，最简单的就是在查询后面加上`limit`。

2. 若是访问太多的列

例如：我只想查询学生的名字，我们应该使用如下语句

```sql
select name from students;
```

而不是使用

```sql
select * from students;
```
这两个方法看起来很基础对不对，虽然基础，但是很有效。其实这也算不上什么优化，只是我们在开发中需要注意的细节问题。

另外需要注意的是，总是取出全部的列，会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的I/O、内存、CPU的消耗，因此，一些DBA是严格禁止使用`select *`这种写法的，这样做有时候还能避免某些列被修改带来的问题。

但是，查询返回超过需要的数据也并不总是坏事，作为后端开发深有体会的一点就是，这种浪费数据库资源的方式可以简化开发。例如，在现在前后端分离的开发中，前端所需要展示哪些字段的数据，都是我们后端查询之后再返回给他的，但是，前端展示的字段并不是一成不变的，并不是总是那几个字段，因为有时候产品需求会变更，比如，今天的需求是展示名字，性别。明天的需求就可能变为展示名字，性别，年龄，身高等等等等。这种情况下，我们就需要频繁的修改我们的代码以满足一天一变的产品需求（需求天天变对于开发来说很苦逼的）。由于经常有这种情况发生，所以一些开发人员就会直接使用`select *`这种写法，不是爱改需求吗，那我就我把数据都给你，你想展示什么自己挑着用吧。。这种方式虽然不满足优化的思想，但是确实简化了开发，但是我们也不能为了简化开发一味的使用`select *`，我们使用这种方式的前提是我们清楚这样做的性能影响。

第二，分析（扫描）了大量超过需要的数据行

在确定查询只返回需要的数据以后，接下来我们应该看看查询为了返回这些结果，是否扫描了过多的数据。在分析查询时，查看该查询扫描的行数是非常有帮助的，这也能在一定程度上说明该查询的效率高不高，也就是`所需行数/扫描行数`的比值高不高。这里我们就要使用到`explain`关键字了，其中`type`列反应了访问类型，从全表扫描到索引扫描，范围扫描，唯一索引查询，常数引用等等。这些速度从慢到快，扫描的行数也是从多到少。如果没有找到合适的访问类型，通常最好的解决办法就是增加一个合适的索引，这也是为什么索引对查询优化这么重要的原因了，因为索引能让MySQL以最高效，扫描行数最少的方式找到需要的记录。

需要注意的是，索引只是尽可能的只扫描所需要的数据行，并不是说增加索引就能让扫描的行数等于返回的行数。例如

```sql
-- 假设actor_id上建索引
select actor_id,count(*) from movie group by actor_id; -- 使用了聚合函数，返回的行数大多数情况下远远小于扫描的行数
```

如果发现查询需要扫描大量的数据但只返回少数的几行，那么通常可以尝试下面的技巧去优化：

1. 使用索引覆盖扫描，把所有需要用的列都放在索引中，这样存储引擎无需回表获取对应行就可以返回结果了。
2. 改变库表结构，例如使用单独的汇总表（例如上述聚合函数的情况优化）
3. 重写复杂查询，让MySQL优化器能够以更优化的方式执行查询
