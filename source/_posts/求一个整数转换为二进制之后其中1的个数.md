---
title: 求一个整数转换为二进制之后其中1的个数
date: 2019-10-09 19:20:01
tags: [算法,LeetCode]
---

今天面试摩拜单车遇到一道算法题，题目如下：

给定一个正整数范围(m,n)，返回一个数组，该数组是每个正整数转换为相应二进制之后包含1的个数

> 示例

```
给定 (1,5) ， 
1的二进制位1，二进制表示中包含位1的个数位1，
2的二进制位10，二进制表示中包含位1的个数位1，
3的二进制为11，二进制表示中包含位1的个数位2，
4的二进制位100，二进制表示中包含位1的个数位1，
5的二进制位101，二进制表示中包含位1的个数位2，
所以返回数组 [1，1，2，1，2]
```

这道题有点像LeetCode上`位1的个数`这道题目。

那么怎么解决呢？

最简单的方法就是，求出每一个数二进制中位1的个数，拼成一个数组，那么如何求出正整数中二进制位1的个数呢？

重点就是求每个数的位1的个数。

这里就要用到位运算了。大家初中高中或者大学学计算机基础的时候应该都学过基础位运算，也就是`与`，`或`，`非`的运算。(还有一些比较复杂的，例如`异或`，`与非`等组合位运算)

代码如下：

```Java
public static int NumberOfOne(int n){
    int count = 0;
    while (n != 0) {
        count++;
        n &= (n - 1);
    }
    return count;
}
```

我们不断把数字最后一个 `1` 反转，并把答案加一。当数字变成 `0` 的时候偶，我们就知道它没有 `1` 的位了，此时返回答案。

这里关键的想法是对于任意数字 `n` ，将 `n` 和 `n-1`做与运算，会把最后一个 `1` 的位变成 `0` 。为什么？考虑 `n` 和 `n−1` 的二进制表示。

我们来详细解读一下 `n & (n - 1)`
1. 假设`n=5`,`n & (n - 1)`就是`5&4`，转换为二进制就是 `101&100=100`
2. 假设`n=4`,`n & (n - 1)`就是`4&3`，转换为二进制就是 `100&011=000`

可以看到，每一次`n&(n-1)`的操作就会把n中的位1减少一位，为什么呢？因为二进制，无论数字是多少，在二进制运算中，只要做了-1的操作，就会改变最后一位的值，1变为0或者0变为1.

1变为0就是上面`1`的情况，
0变为1就是上面`2`的情况。

可以发现，由于每次`- 1`操作都会带了位的变化，所以每次`n&n-1`,都会把二进制中`最后的一位1`消除掉，比如`101&100=100`，消除了`101`最后的1变为`100`，`100&011=000`，消除了`100`最后的`1`，也是惟一的1变为`000`。所以，当我们不断把`n&=n-1`，直到`n=0`的时候，n中的位1就被完全消除了，这个操作做了几次，也就代表n转换为二进制，其中位1的个数有几个。

看到这里，这道题最重要的问题就解决了，剩下的工作就是写个for循环将每位数的结果封装成一个数组就行了，for循环很简单，这里就不再赘述了。

